<html>

<head>
    <title>wolfSSL API Docs</title>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <style type="text/css">
    ol {
        margin: 0;
        padding: 0
    }
    
    .c13 {
        widows: 2;
        orphans: 2;
        margin-left: 36pt
    }
    
    .c26 {
        max-width: 468pt;
        background-color: #ffffff;
        padding: 72pt 72pt 72pt 72pt
    }
    
    .c9 {
        widows: 2;
        orphans: 2;
        margin-left: 54pt
    }
    
    .c7 {
        text-align: center;
        page-break-after: avoid
    }
    
    .c8 {
        color: inherit;
        text-decoration: inherit
    }
    
    .c0 {
        font-size: 10pt;
        font-family: "Courier New"
    }
    
    .c14 {
        text-indent: 36pt;
        margin-left: 36pt
    }
    
    .c1 {
        color: #1155cc;
        text-decoration: underline
    }
    
    .c10 {
        color: #073763;
        font-size: 18pt
    }
    
    .c21 {
        widows: 2;
        orphans: 2
    }
    
    .c12 {
        text-indent: 36pt;
        margin-left: 72pt
    }
    
    .c11 {
        font-family: "Courier New"
    }
    
    .c6 {
        color: #b45f06
    }
    
    .c15 {
        text-indent: 36pt
    }
    
    .c4 {
        direction: ltr
    }
    
    .c2 {
        font-size: 12pt
    }
    
    .c5 {
        height: 11pt
    }
    
    .c16 {
        font-style: italic
    }
    
    .c17 {
        margin-left: 36pt
    }
    
    .c18 {
        page-break-after: avoid
    }
    
    .c19 {
        text-align: center
    }
    
    .c24 {
        margin-left: 180pt
    }
    
    .c27 {
        margin-left: 18pt
    }
    
    .c22 {
        margin-left: 108pt
    }
    
    .c20 {
        margin-left: 216pt
    }
    
    .c25 {
        color: #073763
    }
    
    .c23 {
        margin-left: 144pt
    }
    
    .c3 {
        font-weight: bold
    }
    
    .title {
        widows: 2;
        padding-top: 0pt;
        line-height: 1.15;
        orphans: 2;
        text-align: left;
        color<p>: </p>#000000;
        font-size: 21pt;
        font-family: "Trebuchet MS";
        padding-bottom: 0pt;
        page-break-after: avoid
    }
    
    .subtitle {
        widows: 2;
        padding-top: 0pt;
        line-height: 1.15;
        orphans: 2;
        text-align: left;
        color: #666666;
        font-style: italic;
        font-size: 13pt;
        font-family: "Trebuchet MS";
        padding-bottom: 10pt;
        page-break-after: avoid
    }
    
    li {
        color: #000000;
        font-size: 11pt;
        font-family: "Arial"
    }
    
    p {
        color: #000000;
        font-size: 11pt;
        margin: 0;
        font-family: "Arial"
    }
    
    h1 {
        widows: 2;
        padding-top: 10pt;
        line-height: 1.15;
        orphans: 2;
        text-align: left;
        color: #000000;
        font-size: 16pt;
        font-family: "Trebuchet MS";
        padding-bottom: 0pt;
        page-break-after: avoid
    }
    
    h2 {
        widows: 2;
        padding-top: 10pt;
        line-height: 1.15;
        orphans: 2;
        text-align: left;
        color: #000000;
        font-size: 13pt;
        font-family: "Trebuchet MS";
        font-weight: bold;
        padding-bottom: 0pt;
        page-break-after: avoid
    }
    
    h3 {
        widows: 2;
        padding-top: 8pt;
        line-height: 1.15;
        orphans: 2;
        text-align: left;
        color: #666666;
        font-size: 12pt;
        font-family: "Trebuchet MS";
        font-weight: bold;
        padding-bottom: 0pt;
        page-break-after: avoid
    }
    
    h4 {
        widows: 2;
        padding-top: 8pt;
        line-height: 1.15;
        orphans: 2;
        text-align: left;
        color: #666666;
        font-size: 11pt;
        text-decoration: underline;
        font-family: "Trebuchet MS";
        padding-bottom: 0pt;
        page-break-after: avoid
    }
    
    h5 {
        widows: 2;
        padding-top: 8pt;
        line-height: 1.15;
        orphans: 2;
        text-align: left;
        color: #666666;
        font-size: 11pt;
        font-family: "Trebuchet MS";
        padding-bottom: 0pt;
        page-break-after: avoid
    }
    
    h6 {
        widows: 2;
        padding-top: 8pt;
        line-height: 1.15;
        orphans: 2;
        text-align: left;
        color: #666666;
        font-style: italic;
        font-size: 11pt;
        font-family: "Trebuchet MS";
        padding-bottom: 0pt;
        page-break-after: avoid
    }
    </style>
</head>

<body class="c26">
    <p class="c4 c5"><span class="c3 c10"></span></p>
    <p class="c21 c4 c27"><span class="c1"><a class="c8" href="#h.mc4s6zujijvl">Chapter 17: wolfSSL (formerly CyaSSL) API Reference</a></span></p>
    <p class="c13 c4"><span class="c1"><a class="c8" href="#h.wzkn5w13m1v4">17.1 Initialization / Shutdown</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.q2hhg7o5a5fm">wolfSSL_Init</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.6m7rsdksbyym">wolfSSL_library_init</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.47nl1pbf059n">wolfSSL_Cleanup</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.knh03blbekpy">wolfSSL_shutdown</a></span></p>
    <p class="c13 c4"><span class="c1"><a class="c8" href="#h.z9qbm6barm8a">17.2 Certificates and Keys</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.4k4hevijvhvk">wolfSSL_CTX_load_verify_buffer</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.il0ptxi9291t">wolfSSL_CTX_load_verify_locations</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.jp7nm8qyevod">wolfSSL_CTX_use_PrivateKey_buffer</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.kh1x9hhomeqo">wolfSSL_CTX_use_PrivateKey_file</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.umg9gregjktb">wolfSSL_CTX_use_certificate_buffer</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.rxn1kwjqadsx">wolfSSL_CTX_use_certificate_chain_buffer</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.i1g0rqohbc24">wolfSSL_CTX_use_certificate_chain_file</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.7h9yu6l5a4gp">wolfSSL_CTX_use_certificate_file</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.292d44xlbv76">wolfSSL_SetTmpDH</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.lru389qecqb0">wolfSSL_use_PrivateKey_buffer</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.5paz0kyrtqjl">wolfSSL_use_certificate_buffer</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.xf8z0p1w029h">wolfSSL_use_certificate_chain_buffer</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.fbn3ahz3yddc">wolfSSL_CTX_der_load_verify_locations</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.sfr6x4dq8kd3">wolfSSL_CTX_use_NTRUPrivateKey_file</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.pczzdprw2q80">wolfSSL_KeepArrays</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.iii6ij2nvih2">wolfSSL_FreeArrays</a></span></p>
    <p class="c13 c4"><span class="c1"><a class="c8" href="#h.1xaqdynfcwfo">17.3 Context and Session Setup</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.e0ptphmw2w9d">wolfSSLv3_client_method</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.gx2m2b588a5e">wolfSSLv3_server_method</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.wna7442hgzut">wolfSSLv23_client_method</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.szuwf4k4iqi6">wolfSSLv23_server_method</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.34ic9hpwyl64">wolfTLSv1_client_method</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.5clj6xt5jazj">wolfTLSv1_server_method</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.rxp9tgve7gfv">wolfTLSv1_1_client_method</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.nmq1by3m8rrc">wolfTLSv1_1_server_method</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.b54a569jxsz2">wolfTLSv1_2_client_method</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.qmi1m58ylsmm">wolfTLSv1_2_server_method</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.lhz895ars7ha">wolfDTLSv1_client_method</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.uqfck5bq1dbq">wolfDTLSv1_server_method</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.5vnb1r9tnjtm">wolfSSL_new</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.vnkqp8va6vze">wolfSSL_free</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.4aeia9j2k778">wolfSSL_CTX_new</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.ahrpxjy2dxw2">wolfSSL_CTX_free</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.he9m16b9ebh5">wolfSSL_SetVersion</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.quvbtv9k8c37">wolfSSL_use_old_poly</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.qu12jj1n34ip">wolfSSL_check_domain_name</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.enuqjw3he9ir">wolfSSL_set_cipher_list</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.guoppun2z8ig">wolfSSL_CTX_set_cipher_list</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.qz5k57yop2nl">wolfSSL_set_compression</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.lxf2gktpv9x7">wolfSSL_set_fd</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.boxone6u3bo8">wolfSSL_set_group_messages</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.2zk2h266izaj">wolfSSL_CTX_set_group_messages</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.ifskml2t4qgu">wolfSSL_set_session</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.q4p7h03cnj8f">wolfSSL_CTX_set_session_cache_mode</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.b83o2qg3g1zt">wolfSSL_set_timeout</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.5qrcwcst3x2">wolfSSL_CTX_set_timeout</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.r96upvhk4qb6">wolfSSL_set_using_nonblock</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.9nktkvhn2ona">wolfSSL_set_verify</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.bagbsvfoacgd">wolfSSL_CTX_set_verify</a></span></p>
    <p class="c13 c4"><span class="c1"><a class="c8" href="#h.9552p39wvrhj">17.4 Callbacks</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.7mivrbjjdc8a">wolfSSL_SetIOReadCtx</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.d828pgwcp38r">wolfSSL_SetIOWriteCtx</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.5ovrfntyal3a">wolfSSL_SetIOReadFlags</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.pvzo5ba0177x">wolfSSL_SetIOWriteFlags</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.46014ylme3u3">wolfSSL_SetIORecv</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.5q9uk8qahej">wolfSSL_SetIOSend</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.vbar1z5cbrmg">wolfSSL_CTX_set_TicketEncCb</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.idue3tkqwm3w">wolfSSL_CTX_set_TicketHint</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.kaosw6ufkrhn">wolfSSL_CTX_SetCACb</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.76ckknskgmmk">wolfSSL_connect_ex</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.x9trcbj7cyyb">wolfSSL_accept_ex</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.fa5moasone3n">wolfSSL_SetLoggingCb</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.pocvebv0roxd">wolfSSL_SetTlsHmacInner</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.w5hbqpiucveb">wolfSSL_CTX_SetMacEncryptCb</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.y2wkq7am05ba">wolfSSL_SetMacEncryptCtx</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.tr204u3qimf4">wolfSSL_GetMacEncryptCtx</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.b4eajvor6e2k">wolfSSL_CTX_SetDecryptVerifyCb</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.kab9yu324aqh">wolfSSL_SetDecryptVerifyCtx</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.qj10hrelxth5">wolfSSL_GetDecryptVerifyCtx</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.uleop0yb23t">wolfSSL_CTX_SetEccSignCb</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.kj6qelqqfkc9">wolfSSL_SetEccSignCtx</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.afq3o7wyrc02">wolfSSL_GetEccSignCtx</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.9n9it3r9wufq">wolfSSL_CTX_SetEccVerifyCb</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.a0tvf0kui90u">wolfSSL_SetEccVerifyCtx</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.8c251silgx1l">wolfSSL_GetEccVerifyCtx</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.isul27ek50lv">wolfSSL_CTX_SetRsaSignCb</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.24bj78nkd2yq">wolfSSL_SetRsaSignCtx</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.x2o0c9nf3vxs">wolfSSL_GetRsaSignCtx</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.g2ci12fwqesm">wolfSSL_CTX_SetRsaVerifyCb</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.1uvf06ucwj4r">wolfSSL_SetRsaVerifyCtx</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.scbjtzk6j5nv">wolfSSL_GetRsaVerifyCtx</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.p4c78i30vgpg">wolfSSL_CTX_SetRsaEncCb</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.hhex6xu1xx9j">wolfSSL_SetRsaEncCtx</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.p6d8r7jifxul">wolfSSL_GetRsaEncCtx</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.y6uu2op1horr">wolfSSL_CTX_SetRsaDecCb</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.rgintb4xkx0x">wolfSSL_SetRsaDecCtx</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.fmbrko7brpja">wolfSSL_GetRsaDecCtx</a></span></p>
    <p class="c13 c4"><span class="c1"><a class="c8" href="#h.6j851mv9vu3k">17.5 Error Handling and Debugging</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.5a07619wjhu1">wolfSSL_ERR_error_string</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.kw9km0inzo2z">wolfSSL_ERR_error_string_n</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.crdq814kk20k">wolfSSL_ERR_print_errors_fp</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.wzh6bf3rt4sj">wolfSSL_get_error</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.3s04urt2ec9l">wolfSSL_load_error_strings</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.hci5iomkyzr4">wolfSSL_want_read</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.efi0l46s3uin">wolfSSL_want_write</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.nm1lp4jwk2m1">wolfSSL_Debugging_ON</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.zanp9ofni59i">wolfSSL_Debugging_OFF</a></span></p>
    <p class="c13 c4"><span class="c1"><a class="c8" href="#h.ww63bm3ufrna">17.6 OCSP and CRL</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.so07j5m3s3wz">wolfSSL_CTX_EnableOCSP</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.27gsoc9k6wgs">wolfSSL_CTX_SetOCSP_OverrideURL</a></span></p>
    <p class="c13 c4"><span class="c1"><a class="c8" href="#h.yvnq22vyrc8k">17.7 Informational</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.z3cqacb0yj1i">wolfSSL_GetObjectSize</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.ehsfg7yklg9f">wolfSSL_GetMacSecret</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.2kpsgqplu4oh">wolfSSL_GetClientWriteKey</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.kciowt7xuq6b">wolfSSL_GetClientWriteIV</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.et2fxlw2ig6h">wolfSSL_GetServerWriteKey</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.9j87rsy3yit9">wolfSSL_GetServerWriteIV</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.exspgz8oh3zr">wolfSSL_GetKeySize</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.2s3zjmv15zb">wolfSSL_GetSide</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.i1htj2r7p7yw">wolfSSL_IsTLSv1_1</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.3tok1mcvw0bf">wolfSSL_GetBulkCipher</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.29gkgi3qjqix">wolfSSL_GetAeadMacSize</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.taxx0427c21j">wolfSSL_GetHmacSize</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.cboy486vx3dl">wolfSSL_GetHmacType</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.16ad53l0ww5">wolfSSL_GetCipherType</a></span></p>
    <p class="c13 c4"><span class="c1"><a class="c8" href="#h.h34d25wzbdsf">17.8 Connection, Session, and I/O</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.515wx179txqg">wolfSSL_accept</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.1reog6pqmuiu">wolfSSL_connect</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.sqp4gpyz6uqe">wolfSSL_connect_cert</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.7fi34sxsklbe">wolfSSL_get_fd</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.btz8zz7mwpnj">wolfSSL_get_session</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.f3qesxecprw9">wolfSSL_get_using_nonblock</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.2bbx5ivhiutz">wolfSSL_flush_sessions</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.q6pic56059ps">wolfSSL_negotiate</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.m2mwkzu9m49g">wolfSSL_peek</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.zhveeqr1ci4m">wolfSSL_pending</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.npw5ndkw3vnv">wolfSSL_read</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.mh7at6s3pdhj">wolfSSL_recv</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.dxj1t3penvmb">wolfSSL_send</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.9barj5la9mzr">wolfSSL_write</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.4ci833ts1phb">wolfSSL_writev</a></span></p>
    <p class="c13 c4"><span class="c1"><a class="c8" href="#h.p54j0m2uuoli">17.9 DTLS Specific</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.rlsj8qzbm9ae">wolfSSL_dtls</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.1uhtq8gtxcib">wolfSSL_dtls_get_current_timeout</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.bc4lmnixvaqb">wolfSSL_dtls_get_peer</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.9cvqkeda3a8w">wolfSSL_dtls_got_timeout</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.td3ejguq65m6">wolfSSL_dtls_set_peer</a></span></p>
    <p class="c13 c4"><span class="c1"><a class="c8" href="#h.xqhbpdnjahie">17.10 Memory Abstraction Layer</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.vwl2yq73ku09">wolfSSL_Malloc</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.lm1h99kkdfv">wolfSSL_Realloc</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.b98j75gjqgjf">wolfSSL_Free</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.hbzlb4mxcoif">wolfSSL_SetAllocators</a></span></p>
    <p class="c13 c4"><span class="c1"><a class="c8" href="#h.11ji1koaihw8">17.11 Certificate Manager</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.af6xyn8ukn2c">wolfSSL_CertManagerDisableCRL</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.1x6nm02zpjv0">wolfSSL_CertManagerEnableCRL</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.lyxixwel26rt">wolfSSL_CertManagerFree</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.qpei9rgz6fmc">wolfSSL_CertManagerLoadCA</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.x5sljr29tg1n">wolfSSL_CertManagerNew</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.ykj84golbfbi">wolfSSL_CertManagerVerify</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.q0vp3jdbwp66">wolfSSL_CertManagerVerifyBuffer</a></span></p>
    <p class="c13 c4"><span class="c1"><a class="c8" href="#h.qmod5ysve8ld">17.12 OpenSSL Compatibility Layer</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.kgw0q88zbek8">wolfSSL_X509_get_serial_number</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.ze7h5w1jxq8w">wolfSSL_get_sessionID</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.u8w3ufc6kwb4">wolfSSL_get_peer_chain</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.8lmy79daav40">wolfSSL_get_chain_count</a></span></p>
    <p class="c4 c9"><span class="c1"><a class="c8" href="#h.xbs7pbvfsgm4">wolfSSL_get_chain_length</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.6i4x4fdjx47z">wolfSSL_get_chain_cert</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.i47uoh95cfop">wolfSSL_get_chain_cert_pem</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.etkpb1kk27n8">wolfSSL_PemCertToDer</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.34g8uc73jf0">wolfSSL_CTX_use_RSAPrivateKey_file</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.r8vf20vy82ic">wolfSSL_use_certificate_file</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.b58lmlqy0igi">wolfSSL_use_PrivateKey_file</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.jpkctt54splk">wolfSSL_use_certificate_chain_file</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.jb4tyd7fliov">wolfSSL_use_RSAPrivateKey_file</a></span></p>
    <p class="c4 c13"><span class="c1"><a class="c8" href="#h.ky0z2b51n3eo">17.13 TLS Extensions</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.5ayg9hsdf8ky">wolfSSL_CTX_UseSNI</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.4rh5qnuyj3gi">wolfSSL_UseSNI</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.buo15e2faknw">wolfSSL_CTX_SNI_SetOptions</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.w7xzskcbyhuc">wolfSSL_SNI_SetOptions</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.l5teg5ze70fy">wolfSSL_SNI_GetRequest</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.4ul8xots4ttd">wolfSSL_SNI_GetFromBuffer</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.z1l4j0fthl2d">wolfSSL_CTX_UseMaxFragment</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.y917latf40b7">wolfSSL_UseMaxFragment</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.ukansau8wtrg">wolfSSL_CTX_UseTruncatedHMAC</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.m4n304gfi28">wolfSSL_UseTruncatedHMAC</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.v8htxogcf7cs">wolfSSL_CTX_UseSupportedCurve</a></span></p>
    <p class="c9 c4"><span class="c1"><a class="c8" href="#h.ndnkon67ui3u">wolfSSL_UseSupportedCurve</a></span></p>
    <p class="c21 c4 c5"><span class="c10 c3"></span></p>
    <h1 class="c4 c18"><a name="h.mc4s6zujijvl"></a><span>Chapter 17: wolfSSL (formerly CyaSSL) API Reference</span></h1>
    <p class="c4 c5"><span class="c2 c3 c25"></span></p>
    <h2 class="c4 c18"><a name="h.wzkn5w13m1v4"></a><span>17.1 Initialization / Shutdown</span></h2>
    <hr>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The functions in this section have to do with initializing the wolfSSL library and shutting it down (freeing resources) after it is no longer needed by the application.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.q2hhg7o5a5fm"></a><span>wolfSSL_Init</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_Init(void);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Initializes the wolfSSL library for use. &nbsp;Must be called once per application and before any other call to the library.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_MUTEX_ERROR</span><span class="c2">&nbsp;is an error that may be returned.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2">This function has no parameters.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_Init();</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// failed to initialize wolfSSL library</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_Cleanup</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.6m7rsdksbyym"></a><span>wolfSSL_library_init</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_library_init(void)</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function is done internally in wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">This function is a wrapper around wolfSSL_Init() and exists for OpenSSL compatibility (SSL_library_init) when wolfSSL has been compiled with OpenSSL compatibility layer. &nbsp;wolfSSL_Init() is the more typically-used wolfSSL initialization function.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FATAL_ERROR</span><span class="c2">&nbsp;is returned upon failure.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2">This function takes no parameters.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_library_init();</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// failed to initialize wolfSSL</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_Init</span></p>
    <p class="c4"><span class="c2">wolfSSL_Cleanup</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.47nl1pbf059n"></a><span>wolfSSL_Cleanup</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_Cleanup(void);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Un-initializes the wolfSSL library from further use. &nbsp;Doesn&rsquo;t have to be called, though it will free any resources used by the library.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">No return value for this function.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2">There are no parameters for this function.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">wolfSSL_Cleanup();</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_Init</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.knh03blbekpy"></a><span>wolfSSL_shutdown</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_shutdown(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function shuts down an active SSL/TLS connection using the SSL session, </span><span class="c2 c3">ssl</span><span class="c2">. &nbsp;This function will try to send a &ldquo;close notify&rdquo; alert to the peer.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The calling application can choose to wait for the peer to send its &ldquo;close notify&rdquo; alert in response or just go ahead and shut down the underlying connection after directly calling wolfSSL_shutdown (to save resources). &nbsp;Either option is allowed by the TLS specification. &nbsp;If the underlying connection will be used again in the future, the complete two-directional shutdown procedure must be performed to keep synchronization intact between the peers.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">wolfSSL_shutdown() works with both blocking and non-blocking I/O. &nbsp;When the underlying I/O is non-blocking, wolfSSL_shutdown() will return an error if the underlying I/O could not satisfy the needs of wolfSSL_send() to continue. &nbsp;In this case, a call to wolfSSL_get_error() will yield either </span><span class="c2 c3">SSL_ERROR_WANT_READ</span><span class="c2">&nbsp;or </span><span class="c2 c3">SSL_ERROR_WANT_WRITE</span><span class="c2">. &nbsp;The calling process must then repeat the call to wolfSSL_send() when the underlying I/O is ready.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">0</span><span class="c2">&nbsp;- will be returned upon success.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FATAL_ERROR</span><span class="c2">&nbsp;- will be returned upon failure. &nbsp;Call wolfSSL_get_error() for a more specific error code.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_shutdown(ssl);</span></p>
    <p class="c4"><span class="c0">if (ret != 0) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// failed to shut down SSL connection</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_free</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_free</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h2 class="c4 c18"><a name="h.z9qbm6barm8a"></a><span>17.2 Certificates and Keys</span></h2>
    <hr>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The functions in this section have to do with loading certificates and keys into wolfSSL.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.4k4hevijvhvk"></a><span>wolfSSL_CTX_load_verify_buffer</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">int wolfSSL_CTX_load_verify_buffer(WOLFSSL_CTX* ctx, const unsigned char* in, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; long sz, int format);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function loads a CA certificate buffer into the WOLFSSL Context. &nbsp;It behaves like the non buffered version, only differing in its ability to be called with a buffer as input instead of a file. &nbsp;The buffer is provided by the </span><span class="c2 c3">in</span><span class="c2">&nbsp;argument of size </span><span class="c2 c3">sz</span><span class="c2">. &nbsp;</span><span class="c2 c3">format</span><span class="c2">&nbsp;specifies the format type of the buffer; </span><span class="c2 c3">SSL_FILETYPE_ASN1 </span><span class="c2">or </span><span class="c2 c3">SSL_FILETYPE_PEM</span><span class="c2">. &nbsp;More than one CA certificate may be loaded per buffer as long as the format is in PEM. &nbsp;Please see the examples for proper usage. &nbsp; </span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILETYPE</span><span class="c2">&nbsp;will be returned if the file is the wrong format.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILE</span><span class="c2">&nbsp;will be returned if the file doesn&rsquo;t exist, can&rsquo;t be read, or is corrupted.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_E</span><span class="c2">&nbsp;will be returned if an out of memory condition occurs.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ASN_INPUT_E</span><span class="c2">&nbsp;will be returned if Base16 decoding fails on the file.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BUFFER_E</span><span class="c2">&nbsp;will be returned if a chain buffer is bigger than the receiving buffer.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx </span><span class="c2">- pointer to the SSL context, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">in</span><span class="c2">&nbsp;- pointer to the CA certificate buffer</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">sz - </span><span class="c2">size of the input CA certificate buffer, </span><span class="c2 c3">in</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">format</span><span class="c2">&nbsp;- format of the buffer certificate, either SSL_FILETYPE_ASN1 or SSL_FILETYPE_PEM.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">int sz = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx;</span></p>
    <p class="c4"><span class="c0">byte certBuff[...];</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CTX_load_verify_buffer(ctx, certBuff, sz, SSL_FILETYPE_PEM);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error loading CA certs from buffer</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_load_verify_locations</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_certificate_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_PrivateKey_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_NTRUPrivateKey_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_certificate_chain_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_certificate_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_PrivateKey_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_certificate_chain_buffer</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.il0ptxi9291t"></a><span>wolfSSL_CTX_load_verify_locations</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">int wolfSSL_CTX_load_verify_locations(WOLFSSL_CTX* ctx, const char* file,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const char* path);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function loads PEM-formatted CA certificate files into the SSL context (WOLFSSL_CTX). &nbsp;These certificates will be treated as trusted root certificates and used to verify certs received from peers during the SSL handshake. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The root certificate file, provided by the </span><span class="c2 c3">file</span><span class="c2">&nbsp;argument, may be a single certificate or a file containing multiple certificates. &nbsp;If multiple CA certs are included in the same file, wolfSSL will load them in the same order they are presented in the file. &nbsp;The </span><span class="c2 c3">path</span><span class="c2">&nbsp;argument is a pointer to the name of a directory that contains certificates of trusted root CAs. If the value of </span><span class="c2 c3">file</span><span class="c2">&nbsp;is not NULL, </span><span class="c2 c3">path </span><span class="c2">may be specified as NULL if not needed. &nbsp;If </span><span class="c2 c3">path</span><span class="c2">&nbsp;is specified and NO_WOLFSSL_DIR was not defined when building the library, wolfSSL will load all CA certificates located in the given directory. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">Please see the examples for proper usage.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FAILURE</span><span class="c2">&nbsp;will be returned if </span><span class="c2 c3">ctx</span><span class="c2">&nbsp;is NULL, or if both </span><span class="c2 c3">file</span><span class="c2">&nbsp;and </span><span class="c2 c3">path </span><span class="c2">are NULL.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILETYPE</span><span class="c2">&nbsp;will be returned if the file is the wrong format.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILE</span><span class="c2">&nbsp;will be returned if the file doesn&rsquo;t exist, can&rsquo;t be read, or is corrupted.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_E</span><span class="c2">&nbsp;will be returned if an out of memory condition occurs.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ASN_INPUT_E</span><span class="c2">&nbsp;will be returned if Base16 decoding fails on the file.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BUFFER_E</span><span class="c2">&nbsp;will be returned if a chain buffer is bigger than the receiving buffer.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_PATH_ERROR</span><span class="c2">&nbsp;will be returned if opendir() fails when trying to open </span><span class="c2 c3">path</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx </span><span class="c2">- pointer to the SSL context, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">file</span><span class="c2">&nbsp;- pointer to name of the file containing PEM-formatted CA certificates</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">path - </span><span class="c2">pointer to the name of a directory to load PEM-formatted certificates from.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CTX_load_verify_locations(ctx, &ldquo;./ca-cert.pem&rdquo;, 0);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error loading CA certs</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_load_verify_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_certificate_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_PrivateKey_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_NTRUPrivateKey_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_certificate_chain_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_certificate_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_PrivateKey_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_certificate_chain_file</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.jp7nm8qyevod"></a><span>wolfSSL_CTX_use_PrivateKey_buffer</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">int wolfSSL_CTX_use_PrivateKey_buffer(WOLFSSL_CTX* ctx, const unsigned char* in, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;long sz, int format);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function loads a private key buffer into the SSL Context. &nbsp;It behaves like the non buffered version, only differing in its ability to be called with a buffer as input instead of a file. &nbsp;The buffer is provided by the </span><span class="c2 c3">in</span><span class="c2">&nbsp;argument of size </span><span class="c2 c3">sz</span><span class="c2">. &nbsp;</span><span class="c2 c3">format</span><span class="c2">&nbsp;specifies the format type of the buffer; </span><span class="c2 c3">SSL_FILETYPE_ASN1</span><span class="c2">or </span><span class="c2 c3">SSL_FILETYPE_PEM</span><span class="c2">. &nbsp;Please see the examples for proper usage. &nbsp; </span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILETYPE</span><span class="c2">&nbsp;will be returned if the file is the wrong format.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILE</span><span class="c2">&nbsp;will be returned if the file doesn&rsquo;t exist, can&rsquo;t be read, or is corrupted.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_E</span><span class="c2">&nbsp;will be returned if an out of memory condition occurs.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ASN_INPUT_E</span><span class="c2">&nbsp;will be returned if Base16 decoding fails on the file.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NO_PASSWORD</span><span class="c2">&nbsp;will be returned if the key file is encrypted but no password is provided.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx </span><span class="c2">- pointer to the SSL context, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">in</span><span class="c2">&nbsp;- the input buffer containing the private key to be loaded.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">sz</span><span class="c2">&nbsp;- the size of the input buffer.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">format</span><span class="c2">&nbsp;- the format of the private key located in the input buffer (</span><span class="c2 c3">in</span><span class="c2">). &nbsp;Possible values are SSL_FILETYPE_ASN1 or SSL_FILETYPE_PEM.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">int sz = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx;</span></p>
    <p class="c4"><span class="c0">byte keyBuff[...];</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CTX_use_PrivateKey_buffer(ctx, keyBuff, sz, SSL_FILETYPE_PEM);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error loading private key from buffer</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_load_verify_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_certificate_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_NTRUPrivateKey_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_certificate_chain_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_certificate_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_PrivateKey_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_certificate_chain_buffer</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.kh1x9hhomeqo"></a><span>wolfSSL_CTX_use_PrivateKey_file</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">int wolfSSL_CTX_use_PrivateKey_file(WOLFSSL_CTX* ctx, const char* file, int format);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function loads a private key file into the SSL context (WOLFSSL_CTX). &nbsp;The file is provided by the </span><span class="c2 c3">file</span><span class="c2">&nbsp;argument. &nbsp;The </span><span class="c2 c3">format</span><span class="c2">&nbsp;argument specifies the format type of the file - </span><span class="c2 c3">SSL_FILETYPE_ASN1</span><span class="c2">or </span><span class="c2 c3">SSL_FILETYPE_PEM</span><span class="c2">. &nbsp;Please see the examples for proper usage. &nbsp; </span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">, otherwise </span><span class="c2 c3">SSL_FAILURE</span><span class="c2">&nbsp;will be returned. &nbsp;If the function call fails, possible causes might include:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">- The file is in the wrong format, or the wrong format has been given using the &ldquo;format&rdquo; argument</span></p>
    <p class="c4"><span class="c2">- The file doesn&rsquo;t exist, can&rsquo;t be read, or is corrupted</span></p>
    <p class="c4"><span class="c2">- An out of memory condition occurs</span></p>
    <p class="c4"><span class="c2">- Base16 decoding fails on the file</span></p>
    <p class="c4"><span class="c2">- The key file is encrypted but no password is provided</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CTX_use_PrivateKey_file(ctx, &ldquo;./server-key.pem&rdquo;,</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SSL_FILETYPE_PEM);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error loading key file</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_PrivateKey_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_PrivateKey_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_PrivateKey_buffer</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c4 c7"><a name="h.umg9gregjktb"></a><span>wolfSSL_CTX_use_certificate_buffer</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">int wolfSSL_CTX_use_certificate_buffer(WOLFSSL_CTX* ctx, const unsigned char* in, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;long sz, int format);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function loads a certificate buffer into the WOLFSSL Context. &nbsp;It behaves like the non buffered version, only differing in its ability to be called with a buffer as input instead of a file. &nbsp;The buffer is provided by the </span><span class="c2 c3">in</span><span class="c2">&nbsp;argument of size </span><span class="c2 c3">sz</span><span class="c2">. &nbsp;</span><span class="c2 c3">format</span><span class="c2">&nbsp;specifies the format type of the buffer; </span><span class="c2 c3">SSL_FILETYPE_ASN1 </span><span class="c2">or </span><span class="c2 c3">SSL_FILETYPE_PEM</span><span class="c2">. &nbsp;Please see the examples for proper usage. &nbsp; </span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILETYPE</span><span class="c2">&nbsp;will be returned if the file is the wrong format.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILE</span><span class="c2">&nbsp;will be returned if the file doesn&rsquo;t exist, can&rsquo;t be read, or is corrupted.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_E</span><span class="c2">&nbsp;will be returned if an out of memory condition occurs.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ASN_INPUT_E</span><span class="c2">&nbsp;will be returned if Base16 decoding fails on the file.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx </span><span class="c2">- pointer to the SSL context, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">in</span><span class="c2">&nbsp;- the input buffer containing the certificate to be loaded.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">sz</span><span class="c2">&nbsp;- the size of the input buffer.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">format</span><span class="c2">&nbsp;- the format of the certificate located in the input buffer (</span><span class="c2 c3">in</span><span class="c2">). &nbsp;Possible values are SSL_FILETYPE_ASN1 or SSL_FILETYPE_PEM.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">int sz = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx;</span></p>
    <p class="c4"><span class="c0">byte certBuff[...];</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CTX_use_certificate_buffer(ctx, certBuff, sz, SSL_FILETYPE_PEM);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error loading certificate from buffer</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_load_verify_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_PrivateKey_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_NTRUPrivateKey_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_certificate_chain_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_certificate_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_PrivateKey_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_certificate_chain_buffer</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.rxn1kwjqadsx"></a><span>wolfSSL_CTX_use_certificate_chain_buffer</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">int wolfSSL_CTX_use_certificate_chain_buffer(WOLFSSL_CTX* ctx,</span></p>
    <p class="c15 c4 c20"><span class="c2">const unsigned char* in,</span></p>
    <p class="c15 c4 c20"><span class="c2">long sz);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function loads a certificate chain buffer into the WOLFSSL Context. &nbsp;It behaves like the non buffered version, only differing in its ability to be called with a buffer as input instead of a file. &nbsp;The buffer is provided by the </span><span class="c2 c3">in</span><span class="c2">&nbsp;argument of size </span><span class="c2 c3">sz</span><span class="c2">. &nbsp;The buffer must be in </span><span class="c2 c3">PEM</span><span class="c2">&nbsp;format and start with the subject&rsquo;s certificate, ending with the root certificate. Please see the examples for proper usage. &nbsp; </span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILETYPE</span><span class="c2">&nbsp;will be returned if the file is the wrong format.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILE</span><span class="c2">&nbsp;will be returned if the file doesn&rsquo;t exist, can&rsquo;t be read, or is corrupted.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_E</span><span class="c2">&nbsp;will be returned if an out of memory condition occurs.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ASN_INPUT_E</span><span class="c2">&nbsp;will be returned if Base16 decoding fails on the file.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BUFFER_E</span><span class="c2">&nbsp;will be returned if a chain buffer is bigger than the receiving buffer.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx </span><span class="c2">- pointer to the SSL context, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">in</span><span class="c2">&nbsp;- the input buffer containing the PEM-formatted certificate chain to be loaded.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">sz</span><span class="c2">&nbsp;- the size of the input buffer.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">int sz = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx;</span></p>
    <p class="c4"><span class="c0">byte certChainBuff[...];</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CTX_use_certificate_chain_buffer(ctx, certChainBuff, sz);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error loading certificate chain from buffer</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_load_verify_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_certificate_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_PrivateKey_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_NTRUPrivateKey_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_certificate_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_PrivateKey_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_certificate_chain_buffer</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.i1g0rqohbc24"></a><span>wolfSSL_CTX_use_certificate_chain_file</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">int wolfSSL_CTX_use_certificate_chain_file(WOLFSSL_CTX* ctx, const char* file);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function loads a chain of certificates into the SSL context (WOLFSSL_CTX). &nbsp;The file containing the certificate chain is provided by the </span><span class="c2 c3">file</span><span class="c2">&nbsp;argument, and must contain PEM-formatted certificates. &nbsp;This function will process up to MAX_CHAIN_DEPTH (default = 9, defined in internal.h) certificates, plus the subject cert.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">, otherwise </span><span class="c2 c3">SSL_FAILURE</span><span class="c2">&nbsp;will be returned. &nbsp;If the function call fails, possible causes might include:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">- The file is in the wrong format, or the wrong format has been given using the &ldquo;format&rdquo; argument</span></p>
    <p class="c4"><span class="c2">- file doesn&rsquo;t exist, can&rsquo;t be read, or is corrupted</span></p>
    <p class="c4"><span class="c2">- an out of memory condition occurs</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx</span><span class="c2">&nbsp;- a pointer to a WOLFSSL_CTX structure, created using wolfSSL_CTX_new()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">file</span><span class="c2">&nbsp;- a pointer to the name of the file containing the chain of certificates to be loaded into the wolfSSL SSL context. &nbsp;Certificates must be in PEM format.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CTX_use_certificate_chain_file(ctx, &ldquo;./cert-chain.pem&rdquo;);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error loading cert file</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_certificate_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_certificate_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_certificate_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_certificate_buffer</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.7h9yu6l5a4gp"></a><span>wolfSSL_CTX_use_certificate_file</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">int wolfSSL_CTX_use_certificate_file(WOLFSSL_CTX* ctx, const char* file, int format);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function loads a certificate file into the SSL context (WOLFSSL_CTX). &nbsp;The file is provided by the </span><span class="c2 c3">file</span><span class="c2">&nbsp;argument. &nbsp;The </span><span class="c2 c3">format</span><span class="c2">&nbsp;argument specifies the format type of the file - either </span><span class="c2 c3">SSL_FILETYPE_ASN1 </span><span class="c2">or </span><span class="c2 c3">SSL_FILETYPE_PEM</span><span class="c2">. &nbsp;Please see the examples for proper usage.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">, otherwise </span><span class="c2 c3">SSL_FAILURE</span><span class="c2">&nbsp;will be returned. &nbsp;If the function call fails, possible causes might include:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">- The file is in the wrong format, or the wrong format has been given using the &ldquo;format&rdquo; argument</span></p>
    <p class="c4"><span class="c2">- file doesn&rsquo;t exist, can&rsquo;t be read, or is corrupted</span></p>
    <p class="c4"><span class="c2">- an out of memory condition occurs</span></p>
    <p class="c4"><span class="c2">- Base16 decoding fails on the file</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx</span><span class="c2">&nbsp;- a pointer to a WOLFSSL_CTX structure, created using wolfSSL_CTX_new()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">file</span><span class="c2">&nbsp;- a pointer to the name of the file containing the certificate to be loaded into the wolfSSL SSL context.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">format</span><span class="c2">&nbsp;- format of the certificates pointed to by </span><span class="c2 c3">file</span><span class="c2">. &nbsp;Possible options are SSL_FILETYPE_ASN1 or SSL_FILETYPE_PEM.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CTX_use_certificate_file(ctx, &ldquo;./client-cert.pem&rdquo;,</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SSL_FILETYPE_PEM);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error loading cert file</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_certificate_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_certificate_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_certificate_buffer</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.292d44xlbv76"></a><span>wolfSSL_SetTmpDH</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_SetTmpDH(WOLFSSL* ssl, unsigned char* p, int pSz, unsigned char* g,</span></p>
    <p class="c4 c12"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;int gSz);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Server Diffie-Hellman Ephemeral parameters setting. &nbsp;This function sets up the group parameters to be used if the server negotiates a cipher suite that uses DHE. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_ERROR</span><span class="c2">&nbsp;will be returned if a memory error was encountered.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SIDE_ERROR</span><span class="c2">&nbsp;will be returned if this function is called on an SSL client instead of an SSL server.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL structure, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">p</span><span class="c2">&nbsp;- Diffie-Hellman prime number parameter.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">pSz</span><span class="c2">&nbsp;- size of </span><span class="c2 c3">p</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">g</span><span class="c2">&nbsp;- Diffie-Hellman &ldquo;generator&rdquo; parameter.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">gSz</span><span class="c2">&nbsp;- size of </span><span class="c2 c3">g</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl;</span></p>
    <p class="c4"><span class="c0">static unsigned char p[] = {...};</span></p>
    <p class="c4"><span class="c0">static unsigned char g[] = {...};</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">wolfSSL_SetTmpDH(ssl, p, sizeof(p), g, sizeof(g));</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">SSL_accept</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.lru389qecqb0"></a><span>wolfSSL_use_PrivateKey_buffer</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_use_PrivateKey_buffer(WOLFSSL* ssl, const unsigned char* in, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;long sz, int format);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function loads a private key buffer into the WOLFSSL object. &nbsp;It behaves like the non buffered version, only differing in its ability to be called with a buffer as input instead of a file. &nbsp;The buffer is provided by the </span><span class="c2 c3">in</span><span class="c2">&nbsp;argument of size </span><span class="c2 c3">sz</span><span class="c2">. &nbsp;</span><span class="c2 c3">format</span><span class="c2">&nbsp;specifies the format type of the buffer; </span><span class="c2 c3">SSL_FILETYPE_ASN1 </span><span class="c2">or </span><span class="c2 c3">SSL_FILETYPE_PEM</span><span class="c2">. &nbsp;Please see the examples for proper usage. &nbsp; </span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILETYPE</span><span class="c2">&nbsp;will be returned if the file is the wrong format.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILE</span><span class="c2">&nbsp;will be returned if the file doesn&rsquo;t exist, can&rsquo;t be read, or is corrupted.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_E</span><span class="c2">&nbsp;will be returned if an out of memory condition occurs.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ASN_INPUT_E</span><span class="c2">&nbsp;will be returned if Base16 decoding fails on the file.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NO_PASSWORD</span><span class="c2">&nbsp;will be returned if the key file is encrypted but no password is provided.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">in</span><span class="c2">&nbsp;- buffer containing private key to load.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">sz</span><span class="c2">&nbsp;- size of the private key located in </span><span class="c2 c3">buffer</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">format</span><span class="c2">&nbsp;- format of the private key to be loaded. &nbsp;Possible values are SSL_FILETYPE_ASN1 or SSL_FILETYPE_PEM.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int buffSz;</span></p>
    <p class="c4"><span class="c0">int ret;</span></p>
    <p class="c4"><span class="c0">byte keyBuff[...];</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_use_PrivateKey_buffer(ssl, keyBuff, buffSz, SSL_FILETYPE_PEM);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// failed to load private key from buffer</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_load_verify_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_certificate_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_PrivateKey_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_NTRUPrivateKey_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_certificate_chain_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_certificate_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_certificate_chain_buffer</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.5paz0kyrtqjl"></a><span>wolfSSL_use_certificate_buffer</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_use_certificate_buffer(WOLFSSL* ssl, const unsigned char* in, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; long sz, int format);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function loads a certificate buffer into the WOLFSSL object. &nbsp;It behaves like the non buffered version, only differing in its ability to be called with a buffer as input instead of a file. &nbsp;The buffer is provided by the </span><span class="c2 c3">in</span><span class="c2">&nbsp;argument of size </span><span class="c2 c3">sz</span><span class="c2">. &nbsp;</span><span class="c2 c3">format</span><span class="c2">&nbsp;specifies the format type of the buffer; </span><span class="c2 c3">SSL_FILETYPE_ASN1 </span><span class="c2">or </span><span class="c2 c3">SSL_FILETYPE_PEM</span><span class="c2">. &nbsp;Please see the examples for proper usage. &nbsp; </span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILETYPE</span><span class="c2">&nbsp;will be returned if the file is the wrong format.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILE</span><span class="c2">&nbsp;will be returned if the file doesn&rsquo;t exist, can&rsquo;t be read, or is corrupted.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_E</span><span class="c2">&nbsp;will be returned if an out of memory condition occurs.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ASN_INPUT_E</span><span class="c2">&nbsp;will be returned if Base16 decoding fails on the file.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">in</span><span class="c2">&nbsp;- buffer containing certificate to load.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">sz</span><span class="c2">&nbsp;- size of the certificate located in </span><span class="c2 c3">buffer</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">format</span><span class="c2">&nbsp;- format of the certificate to be loaded. &nbsp;Possible values are SSL_FILETYPE_ASN1 or SSL_FILETYPE_PEM.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int buffSz;</span></p>
    <p class="c4"><span class="c0">int ret;</span></p>
    <p class="c4"><span class="c0">byte certBuff[...];</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_use_certificate_buffer(ssl, certBuff, buffSz, SSL_FILETYPE_PEM);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// failed to load certificate from buffer</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_load_verify_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_certificate_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_PrivateKey_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_NTRUPrivateKey_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_certificate_chain_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_PrivateKey_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_certificate_chain_buffer</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.xf8z0p1w029h"></a><span>wolfSSL_use_certificate_chain_buffer</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_use_certificate_chain_buffer(WOLFSSL* ssl, const unsigned char* in, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; long sz);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function loads a certificate chain buffer into the WOLFSSL object. &nbsp;It behaves like the non buffered version, only differing in its ability to be called with a buffer as input instead of a file. &nbsp;The buffer is provided by the </span><span class="c2 c3">in</span><span class="c2">&nbsp;argument of size </span><span class="c2 c3">sz</span><span class="c2">. &nbsp;The buffer must be in </span><span class="c2 c3">PEM</span><span class="c2">&nbsp;format and start with the subject&rsquo;s certificate, ending with the root certificate. Please see the examples for proper usage. &nbsp; </span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILETYPE</span><span class="c2">&nbsp;will be returned if the file is the wrong format.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILE</span><span class="c2">&nbsp;will be returned if the file doesn&rsquo;t exist, can&rsquo;t be read, or is corrupted.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_E</span><span class="c2">&nbsp;will be returned if an out of memory condition occurs.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ASN_INPUT_E</span><span class="c2">&nbsp;will be returned if Base16 decoding fails on the file.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BUFFER_E</span><span class="c2">&nbsp;will be returned if a chain buffer is bigger than the receiving buffer.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">in</span><span class="c2">&nbsp;- buffer containing certificate to load.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">sz</span><span class="c2">&nbsp;- size of the certificate located in </span><span class="c2 c3">buffer</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int buffSz;</span></p>
    <p class="c4"><span class="c0">int ret;</span></p>
    <p class="c4"><span class="c0">byte certChainBuff[...];</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_use_certificate_chain_buffer(ssl, certChainBuff, buffSz);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// failed to load certificate chain from buffer</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_load_verify_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_certificate_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_PrivateKey_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_NTRUPrivateKey_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_certificate_chain_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_certificate_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_PrivateKey_buffer</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.fbn3ahz3yddc"></a><span>wolfSSL_CTX_der_load_verify_locations</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_CTX_der_load_verify_locations(WOLFSSL_CTX* ctx, const char* file,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int format);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function is similar to wolfSSL_CTX_load_verify_locations, but allows the loading of DER-formatted CA files into the SSL context (WOLFSSL_CTX). &nbsp;It may still be used to load PEM-formatted CA files as well. &nbsp;These certificates will be treated as trusted root certificates and used to verify certs received from peers during the SSL handshake. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The root certificate file, provided by the </span><span class="c2 c3">file</span><span class="c2">&nbsp;argument, may be a single certificate or a file containing multiple certificates. &nbsp;If multiple CA certs are included in the same file, wolfSSL will load them in the same order they are presented in the file. &nbsp;The </span><span class="c2 c3">format</span><span class="c2">&nbsp;argument specifies the format which the certificates are in - either SSL_FILETYPE_PEM or SSL_FILETYPE_ASN1 (DER). &nbsp;Unlike wolfSSL_CTX_load_verify_locations, this function does not allow the loading of CA certificates from a given directory path.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">Note that this function is only available when the wolfSSL library was compiled with WOLFSSL_DER_LOAD defined.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">, otherwise </span><span class="c2 c3">SSL_FAILURE</span><span class="c2">&nbsp;will be returned upon failure.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx</span><span class="c2">&nbsp;- a pointer to a WOLFSSL_CTX structure, created using wolfSSL_CTX_new()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">file</span><span class="c2">&nbsp;- a pointer to the name of the file containing the CA certificates to be loaded into the wolfSSL SSL context, with format as specified by </span><span class="c2 c3">format</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">format</span><span class="c2">&nbsp;- the encoding type of the certificates specified by </span><span class="c2 c3">file</span><span class="c2">. &nbsp;Possible values include SSL_FILETYPE_PEM and SSL_FILETYPE_ASN1.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CTX_der_load_verify_locations(ctx, &ldquo;./ca-cert.der&rdquo;,</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SSL_FILETYPE_ASN1);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error loading CA certs</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_load_verify_locations</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_load_verify_buffer</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.sfr6x4dq8kd3"></a><span>wolfSSL_CTX_use_NTRUPrivateKey_file</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_CTX_use_NTRUPrivateKey_file(WOLFSSL_CTX* ctx, const char* file);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function loads an NTRU private key file into the WOLFSSL Context. &nbsp;It behaves like the normal version, only differing in its ability to accept an NTRU raw key file. &nbsp; This function is needed since the format of the file is different than the normal key file (buffer) functions. &nbsp;Please see the examples for proper usage. &nbsp; </span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILE</span><span class="c2">&nbsp;will be returned if the file doesn&rsquo;t exist, can&rsquo;t be read, or is corrupted.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_E</span><span class="c2">&nbsp;will be returned if an out of memory condition occurs.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ASN_INPUT_E</span><span class="c2">&nbsp;will be returned if Base16 decoding fails on the file.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BUFFER_E</span><span class="c2">&nbsp;will be returned if a chain buffer is bigger than the receiving buffer.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NO_PASSWORD</span><span class="c2">&nbsp;will be returned if the key file is encrypted but no password is provided.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx</span><span class="c2">&nbsp;- a pointer to a WOLFSSL_CTX structure, created using wolfSSL_CTX_new()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">file</span><span class="c2">&nbsp;- a pointer to the name of the file containing the NTRU private key to be loaded into the wolfSSL SSL context.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CTX_use_NTRUPrivateKey_file(ctx, &ldquo;./ntru-key.raw&rdquo;);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error loading NTRU private key</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_load_verify_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_certificate_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_PrivateKey_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_certificate_chain_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_certificate_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_PrivateKey_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_certificate_chain_buffer</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.pczzdprw2q80"></a><span>wolfSSL_KeepArrays</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_KeepArrays(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Normally, at the end of the SSL handshake, wolfSSL frees temporary arrays. &nbsp;Calling this function before the handshake begins will prevent wolfSSL from freeing temporary arrays. &nbsp;Temporary arrays may be needed for things such as wolfSSL_get_keys() or PSK hints.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">When the user is done with temporary arrays, either wolfSSL_FreeArrays() may be called to free the resources immediately, or alternatively the resources will be freed when the associated SSL object is freed.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">This function has no return value.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL structure, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">wolfSSL_KeepArrays(ssl);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_FreeArrays</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.iii6ij2nvih2"></a><span>wolfSSL_FreeArrays</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_FreeArrays(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Normally, at the end of the SSL handshake, wolfSSL frees temporary arrays. &nbsp;If wolfSSL_KeepArrays() has been called before the handshake, wolfSSL will not free temporary arrays. &nbsp;This function explicitly frees temporary arrays and should be called when the user is done with temporary arrays and does not want to wait for the SSL object to be freed to free these resources.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">This function has no return value.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL structure, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">wolfSSL_FreeArrays(ssl);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_KeepArrays</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h2 class="c21 c4 c18"><a name="h.1xaqdynfcwfo"></a><span>17.3 Context and Session Setup</span></h2>
    <hr>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The functions in this section have to do with creating and setting up SSL/TLS context objects (WOLFSSL_CTX) and SSL/TLS session objects (WOLFSSL).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.e0ptphmw2w9d"></a><span>wolfSSLv3_client_method</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">WOLFSSL_METHOD *wolfSSLv3_client_method(void);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">The wolfSSLv3_client_method() function is used to indicate that the application is a client and will only support the SSL 3.0 protocol. &nbsp;This function allocates memory for and initializes a new WOLFSSL_METHOD structure to be used when creating the SSL/TLS context with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful, the call will return a pointer to the newly created WOLFSSL_METHOD structure. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If memory allocation fails when calling XMALLOC, the failure value of the underlying malloc() implementation will be returned (typically NULL with errno will be set to ENOMEM).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2">This function has no parameters.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_METHOD* method;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">method = wolfSSLv3_client_method();</span></p>
    <p class="c4"><span class="c0">if (method == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// unable to get method</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_client_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_1_client_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_2_client_method</span></p>
    <p class="c4"><span class="c2">wolfDTLSv1_client_method</span></p>
    <p class="c4"><span class="c2">wolfSSLv23_client_method</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.gx2m2b588a5e"></a><span>wolfSSLv3_server_method</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">WOLFSSL_METHOD *wolfSSLv3_server_method(void);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">The wolfSSLv3_server_method() function is used to indicate that the application is a server and will only support the SSL 3.0 protocol. &nbsp;This function allocates memory for and initializes a new WOLFSSL_METHOD structure to be used when creating the SSL/TLS context with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful, the call will return a pointer to the newly created WOLFSSL_METHOD structure. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If memory allocation fails when calling XMALLOC, the failure value of the underlying malloc() implementation will be returned (typically NULL with errno will be set to ENOMEM).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2">This function has no parameters.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_METHOD* method;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">method = wolfSSLv3_server_method();</span></p>
    <p class="c4"><span class="c0">if (method == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// unable to get method</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_server_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_1_server_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_2_server_method</span></p>
    <p class="c4"><span class="c2">wolfDTLSv1_server_method</span></p>
    <p class="c4"><span class="c2">wolfSSLv23_server_method</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.wna7442hgzut"></a><span>wolfSSLv23_client_method</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">WOLFSSL_METHOD *wolfSSLv23_client_method(void);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">The wolfSSLv23_client_method() function is used to indicate that the application is a client and will support the highest protocol version supported by the server between SSL 3.0 - TLS 1.2. &nbsp;This function allocates memory for and initializes a new WOLFSSL_METHOD structure to be used when creating the SSL/TLS context with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">Both wolfSSL clients and servers have robust version downgrade capability. &nbsp;If a specific protocol version method is used on either side, then only that version will be negotiated or an error will be returned. &nbsp;For example, a client that uses TLSv1 and tries to connect to a SSLv3 only server will fail, likewise connecting to a TLSv1.1 will fail as well. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">To resolve this issue, a client that uses the wolfSSLv23_client_method() function will use the highest protocol version supported by the server and downgrade to SSLv3 if needed. In this case, the client will be able to connect to a server running SSLv3 - TLSv1.2.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful, the call will return a pointer to the newly created WOLFSSL_METHOD structure. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If memory allocation fails when calling XMALLOC, the failure value of the underlying malloc() implementation will be returned (typically NULL with errno will be set to ENOMEM).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2">This function has no parameters.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_METHOD* method;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">method = wolfSSLv23_client_method();</span></p>
    <p class="c4"><span class="c0">if (method == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// unable to get method</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSLv3_client_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_client_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_1_client_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_2_client_method</span></p>
    <p class="c4"><span class="c2">wolfDTLSv1_client_method</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.szuwf4k4iqi6"></a><span>wolfSSLv23_server_method</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">WOLFSSL_METHOD *wolfSSLv23_server_method(void);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">The wolfSSLv23_server_method() function is used to indicate that the application is a server and will support clients connecting with protocol version from SSL 3.0 - TLS 1.2. &nbsp;This function allocates memory for and initializes a new WOLFSSL_METHOD structure to be used when creating the SSL/TLS context with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful, the call will return a pointer to the newly created WOLFSSL_METHOD structure. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If memory allocation fails when calling XMALLOC, the failure value of the underlying malloc() implementation will be returned (typically NULL with errno will be set to ENOMEM).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2">This function has no parameters.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_METHOD* method;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">method = wolfSSLv23_server_method();</span></p>
    <p class="c4"><span class="c0">if (method == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// unable to get method</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSLv3_server_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_server_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_1_server_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_2_server_method</span></p>
    <p class="c4"><span class="c2">wolfDTLSv1_server_method</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.34ic9hpwyl64"></a><span>wolfTLSv1_client_method</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">WOLFSSL_METHOD *wolfTLSv1_client_method(void);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">The wolfTLSv1_client_method() function is used to indicate that the application is a client and will only support the TLS 1.0 protocol. &nbsp;This function allocates memory for and initializes a new WOLFSSL_METHOD structure to be used when creating the SSL/TLS context with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful, the call will return a pointer to the newly created WOLFSSL_METHOD structure. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If memory allocation fails when calling XMALLOC, the failure value of the underlying malloc() implementation will be returned (typically NULL with errno will be set to ENOMEM).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_METHOD* method;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">method = wolfTLSv1_client_method();</span></p>
    <p class="c4"><span class="c0">if (method == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// unable to get method</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSLv3_client_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_1_client_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_2_client_method</span></p>
    <p class="c4"><span class="c2">wolfDTLSv1_client_method</span></p>
    <p class="c4"><span class="c2">wolfSSLv23_client_method</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.5clj6xt5jazj"></a><span>wolfTLSv1_server_method</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">WOLFSSL_METHOD *wolfTLSv1_server_method(void);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">The wolfTLSv1_server_method() function is used to indicate that the application is a server and will only support the TLS 1.0 protocol. &nbsp;This function allocates memory for and initializes a new WOLFSSL_METHOD structure to be used when creating the SSL/TLS context with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful, the call will return a pointer to the newly created WOLFSSL_METHOD structure. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If memory allocation fails when calling XMALLOC, the failure value of the underlying malloc() implementation will be returned (typically NULL with errno will be set to ENOMEM).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_METHOD* method;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">method = wolfTLSv1_server_method();</span></p>
    <p class="c4"><span class="c0">if (method == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// unable to get method</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSLv3_server_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_1_server_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_2_server_method</span></p>
    <p class="c4"><span class="c2">wolfDTLSv1_server_method</span></p>
    <p class="c4"><span class="c2">wolfSSLv23_server_method</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.rxp9tgve7gfv"></a><span>wolfTLSv1_1_client_method</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">WOLFSSL_METHOD *wolfTLSv1_1_client_method(void);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">The wolfTLSv1_1_client_method() function is used to indicate that the application is a client and will only support the TLS 1.0 protocol. &nbsp;This function allocates memory for and initializes a new WOLFSSL_METHOD structure to be used when creating the SSL/TLS context with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful, the call will return a pointer to the newly created WOLFSSL_METHOD structure. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If memory allocation fails when calling XMALLOC, the failure value of the underlying malloc() implementation will be returned (typically NULL with errno will be set to ENOMEM).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_METHOD* method;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">method = wolfTLSv1_1_client_method();</span></p>
    <p class="c4"><span class="c0">if (method == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// unable to get method</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSLv3_client_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_client_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_2_client_method</span></p>
    <p class="c4"><span class="c2">wolfDTLSv1_client_method</span></p>
    <p class="c4"><span class="c2">wolfSSLv23_client_method</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.nmq1by3m8rrc"></a><span>wolfTLSv1_1_server_method</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">WOLFSSL_METHOD *wolfTLSv1_1_server_method(void);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">The wolfTLSv1_1_server_method() function is used to indicate that the application is a server and will only support the TLS 1.1 protocol. &nbsp;This function allocates memory for and initializes a new WOLFSSL_METHOD structure to be used when creating the SSL/TLS context with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful, the call will return a pointer to the newly created WOLFSSL_METHOD structure. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If memory allocation fails when calling XMALLOC, the failure value of the underlying malloc() implementation will be returned (typically NULL with errno will be set to ENOMEM).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_METHOD* method;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">method = wolfTLSv1_1_server_method();</span></p>
    <p class="c4"><span class="c0">if (method == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// unable to get method</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSLv3_server_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_server_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_2_server_method</span></p>
    <p class="c4"><span class="c2">wolfDTLSv1_server_method</span></p>
    <p class="c4"><span class="c2">wolfSSLv23_server_method</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.b54a569jxsz2"></a><span>wolfTLSv1_2_client_method</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">WOLFSSL_METHOD *wolfTLSv1_2_client_method(void);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">The wolfTLSv1_2_client_method() function is used to indicate that the application is a client and will only support the TLS 1.2 protocol. &nbsp;This function allocates memory for and initializes a new WOLFSSL_METHOD structure to be used when creating the SSL/TLS context with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful, the call will return a pointer to the newly created WOLFSSL_METHOD structure. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If memory allocation fails when calling XMALLOC, the failure value of the underlying malloc() implementation will be returned (typically NULL with errno will be set to ENOMEM).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_METHOD* method;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">method = wolfTLSv1_2_client_method();</span></p>
    <p class="c4"><span class="c0">if (method == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// unable to get method</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSLv3_client_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_client_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_1_client_method</span></p>
    <p class="c4"><span class="c2">wolfDTLSv1_client_method</span></p>
    <p class="c4"><span class="c2">wolfSSLv23_client_method</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.qmi1m58ylsmm"></a><span>wolfTLSv1_2_server_method</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">WOLFSSL_METHOD *wolfTLSv1_2_server_method(void);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">The wolfTLSv1_2_server_method() function is used to indicate that the application is a server and will only support the TLS 1.2 protocol. &nbsp;This function allocates memory for and initializes a new WOLFSSL_METHOD structure to be used when creating the SSL/TLS context with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful, the call will return a pointer to the newly created WOLFSSL_METHOD structure. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If memory allocation fails when calling XMALLOC, the failure value of the underlying malloc() implementation will be returned (typically NULL with errno will be set to ENOMEM).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_METHOD* method;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">method = wolfTLSv1_2_server_method();</span></p>
    <p class="c4"><span class="c0">if (method == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// unable to get method</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSLv3_server_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_server_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_1_server_method</span></p>
    <p class="c4"><span class="c2">wolfDTLSv1_server_method</span></p>
    <p class="c4"><span class="c2">wolfSSLv23_server_method</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.lhz895ars7ha"></a><span>wolfDTLSv1_client_method</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">WOLFSSL_METHOD *wolfDTLSv1_client_method(void);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">The wolfDTLSv1_client_method() function is used to indicate that the application is a client and will only support the DTLS 1.0 protocol. &nbsp;This function allocates memory for and initializes a new WOLFSSL_METHOD structure to be used when creating the SSL/TLS context with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful, the call will return a pointer to the newly created WOLFSSL_METHOD structure. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If memory allocation fails when calling XMALLOC, the failure value of the underlying malloc() implementation will be returned (typically NULL with errno will be set to ENOMEM).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_METHOD* method;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">method = wolfDTLSv1_client_method();</span></p>
    <p class="c4"><span class="c0">if (method == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// unable to get method</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSLv3_client_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_client_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_1_client_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_2_client_method</span></p>
    <p class="c4"><span class="c2">wolfSSLv23_client_method</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.uqfck5bq1dbq"></a><span>wolfDTLSv1_server_method</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">WOLFSSL_METHOD *wolfDTLSv1_server_method(void);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">The wolfDTLSv1_server_method() function is used to indicate that the application is a server and will only support the DTLS 1.0 protocol. &nbsp;This function allocates memory for and initializes a new WOLFSSL_METHOD structure to be used when creating the SSL/TLS context with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful, the call will return a pointer to the newly created WOLFSSL_METHOD structure. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If memory allocation fails when calling XMALLOC, the failure value of the underlying malloc() implementation will be returned (typically NULL with errno will be set to ENOMEM).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_METHOD* method;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">method = wolfDTLSv1_server_method();</span></p>
    <p class="c4"><span class="c0">if (method == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// unable to get method</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSLv3_server_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_server_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_1_server_method</span></p>
    <p class="c4"><span class="c2">wolfTLSv1_2_server_method</span></p>
    <p class="c4"><span class="c2">wolfSSLv23_server_method</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.5vnb1r9tnjtm"></a><span>wolfSSL_new</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">WOLFSSL* wolfSSL_new(WOLFSSL_CTX* ctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function creates a new SSL session, taking an already created SSL context as input.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return a pointer to the newly-created WOLFSSL structure. &nbsp;Upon failure, NULL will be returned.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx </span><span class="c2">- pointer to the SSL context, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL* &nbsp; &nbsp; ssl = NULL;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx = 0;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4"><span class="c0">if (ctx == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// context creation failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ssl = wolfSSL_new(ctx);</span></p>
    <p class="c4"><span class="c0">if (ssl == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// SSL object creation failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.vnkqp8va6vze"></a><span>wolfSSL_free</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_free(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function frees an allocated WOLFSSL object.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">No return values are used for this function.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL object, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">wolfSSL_free(ssl);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4"><span class="c2">wolfSSL_new</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_free</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.4aeia9j2k778"></a><span>wolfSSL_CTX_new</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">WOLFSSL_CTX* wolfSSL_CTX_new(WOLFSSL_METHOD* method);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function creates a new SSL context, taking a desired SSL/TLS protocol method for input.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return a pointer to the newly-created WOLFSSL_CTX. &nbsp;Upon failure, NULL will be returned.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">method</span><span class="c2">&nbsp;- pointer to the desired WOLFSSL_METHOD to use for the SSL context. This is created using one of the wolfSSLvXX_XXXX_method() functions to specify SSL/TLS/DTLS protocol level.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* &nbsp; &nbsp;ctx &nbsp; &nbsp;= 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_METHOD* method = 0;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">method = wolfSSLv3_client_method();</span></p>
    <p class="c4"><span class="c0">if (method == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// unable to get method</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4"><span class="c0">if (ctx == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// context creation failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_new</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.ahrpxjy2dxw2"></a><span>wolfSSL_CTX_free</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">void wolfSSL_CTX_free(WOLFSSL_CTX* ctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function frees an allocated WOLFSSL_CTX object. &nbsp;This function decrements the CTX reference count and only frees the context when the reference count has reached 0.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">No return values are used for this function.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx </span><span class="c2">- pointer to the SSL context, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">wolfSSL_CTX_free(ctx);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4"><span class="c2">wolfSSL_new</span></p>
    <p class="c4"><span class="c2">wolfSSL_free</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.he9m16b9ebh5"></a><span>wolfSSL_SetVersion</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_SetVersion(WOLFSSL* ssl, int version);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function sets the SSL/TLS protocol version for the specified SSL session (WOLFSSL object) using the version as specified by </span><span class="c2 c3">version</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">This will override the protocol setting for the SSL session (</span><span class="c2 c3">ssl</span><span class="c2">) - originally defined and set by the SSL context (wolfSSL_CTX_new()) method type.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;will be returned if the input SSL object is NULL or an incorrect protocol version is given for </span><span class="c2 c3">version</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL structure, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">version</span><span class="c2">&nbsp;- SSL/TLS protocol version. &nbsp;Possible values include WOLFSSL_SSLV3, WOLFSSL_TLSV1, WOLFSSL_TLSV1_1, WOLFSSL_TLSV1_2.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_SetVersion(ssl, WOLFSSL_TLSV1);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c15 c4"><span class="c0">// failed to set SSL session protocol version<br>}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.quvbtv9k8c37"></a><span>wolfSSL_use_old_poly</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_use_old_poly(WOLFSSL* ssl, int flag);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
    <p class="c4"><span class="c2">Since there is some differences between the first release and newer versions of chacha-poly AEAD construction we have added an option to communicate with servers / clients using the older version. By default wolfSSL uses the new version.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">0</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL structure, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">flag</span><span class="c2">&nbsp;- whether or not to use the older version of setting up the information for poly1305. Passing a flag value of one indicates yes use the old poly AEAD, to switch back to using the new version pass a flag value of 0.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_use_old_poly(ssl, 1);</span></p>
    <p class="c4"><span class="c0">if (ret != 0) {</span></p>
    <p class="c15 c4"><span class="c0">// failed to set poly1305 AEAD version<br>}</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.qu12jj1n34ip"></a><span>wolfSSL_check_domain_name</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_check_domain_name(WOLFSSL* ssl, const char* dn);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">wolfSSL by default checks the peer certificate for a valid date range and a verified signature. &nbsp;Calling this function before wolfSSL_connect() or wolfSSL_accept() will add a domain name check to the list of checks to perform. &nbsp;</span><span class="c2 c3">dn</span><span class="c2">&nbsp;holds the domain name to check against the peer certificate when it&rsquo;s received.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FAILURE</span><span class="c2">&nbsp;will be returned if a memory error was encountered.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL structure, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">dn</span><span class="c2">&nbsp;- domain name to check against the peer certificate when received.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl;</span></p>
    <p class="c4"><span class="c0">char* domain = (char*) &ldquo;www.yassl.com&rdquo;;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_check_domain_name(ssl, domain);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c15 c4"><span class="c0">// failed to enable domain name check<br>}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">NA</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.enuqjw3he9ir"></a><span>wolfSSL_set_cipher_list</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_set_cipher_list(WOLFSSL* ssl, const char* list);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function sets cipher suite list for a given WOLFSSL object (SSL session). &nbsp;The ciphers in the list should be sorted in order of preference from highest to lowest. &nbsp;Each call to wolfSSL_set_cipher_list() resets the cipher suite list for the specific SSL session to the provided list each time the function is called.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The cipher suite list, </span><span class="c2 c3">list</span><span class="c2">, is a null-terminated text string, and a colon-delimited list. &nbsp;For example, one value for </span><span class="c2 c3">list</span><span class="c2">&nbsp;may be</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">&quot;DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:AES256-SHA256&quot;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">Valid cipher values are the full name values from the cipher_names[] array in src/internal.c:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">RC4-SHA</span></p>
    <p class="c4"><span class="c2">RC4-MD5</span></p>
    <p class="c4"><span class="c2">DES-CBC3-SHA</span></p>
    <p class="c4"><span class="c2">AES128-SHA</span></p>
    <p class="c4"><span class="c2">AES256-SHA</span></p>
    <p class="c4"><span class="c2">NULL-SHA</span></p>
    <p class="c4"><span class="c2">NULL-SHA256</span></p>
    <p class="c4"><span class="c2">DHE-RSA-AES128-SHA</span></p>
    <p class="c4"><span class="c2">DHE-RSA-AES256-SHA</span></p>
    <p class="c4"><span class="c2">PSK-AES128-CBC-SHA256</span></p>
    <p class="c4"><span class="c2">PSK-AES128-CBC-SHA</span></p>
    <p class="c4"><span class="c2">PSK-AES256-CBC-SHA</span></p>
    <p class="c4"><span class="c2">PSK-NULL-SHA256</span></p>
    <p class="c4"><span class="c2">PSK-NULL-SHA</span></p>
    <p class="c4"><span class="c2">HC128-MD5</span></p>
    <p class="c4"><span class="c2">HC128-SHA</span></p>
    <p class="c4"><span class="c2">HC128-B2B256</span></p>
    <p class="c4"><span class="c2">AES128-B2B256</span></p>
    <p class="c4"><span class="c2">AES256-B2B256</span></p>
    <p class="c4"><span class="c2">RABBIT-SHA</span></p>
    <p class="c4"><span class="c2">NTRU-RC4-SHA</span></p>
    <p class="c4"><span class="c2">NTRU-DES-CBC3-SHA</span></p>
    <p class="c4"><span class="c2">NTRU-AES128-SHA</span></p>
    <p class="c4"><span class="c2">NTRU-AES256-SHA</span></p>
    <p class="c4"><span class="c2">AES128-CCM-8</span></p>
    <p class="c4"><span class="c2">AES256-CCM-8</span></p>
    <p class="c4"><span class="c2">ECDHE-ECDSA-AES128-CCM-8</span></p>
    <p class="c4"><span class="c2">ECDHE-ECDSA-AES256-CCM-8</span></p>
    <p class="c4"><span class="c2">ECDHE-RSA-AES128-SHA</span></p>
    <p class="c4"><span class="c2">ECDHE-RSA-AES256-SHA</span></p>
    <p class="c4"><span class="c2">ECDHE-ECDSA-AES128-SHA</span></p>
    <p class="c4"><span class="c2">ECDHE-ECDSA-AES256-SHA</span></p>
    <p class="c4"><span class="c2">ECDHE-RSA-RC4-SHA</span></p>
    <p class="c4"><span class="c2">ECDHE-RSA-DES-CBC3-SHA</span></p>
    <p class="c4"><span class="c2">ECDHE-ECDSA-RC4-SHA</span></p>
    <p class="c4"><span class="c2">ECDHE-ECDSA-DES-CBC3-SHA</span></p>
    <p class="c4"><span class="c2">AES128-SHA256</span></p>
    <p class="c4"><span class="c2">AES256-SHA256</span></p>
    <p class="c4"><span class="c2">DHE-RSA-AES128-SHA256</span></p>
    <p class="c4"><span class="c2">DHE-RSA-AES256-SHA256</span></p>
    <p class="c4"><span class="c2">ECDH-RSA-AES128-SHA</span></p>
    <p class="c4"><span class="c2">ECDH-RSA-AES256-SHA</span></p>
    <p class="c4"><span class="c2">ECDH-ECDSA-AES128-SHA</span></p>
    <p class="c4"><span class="c2">ECDH-ECDSA-AES256-SHA</span></p>
    <p class="c4"><span class="c2">ECDH-RSA-RC4-SHA</span></p>
    <p class="c4"><span class="c2">ECDH-RSA-DES-CBC3-SHA</span></p>
    <p class="c4"><span class="c2">ECDH-ECDSA-RC4-SHA</span></p>
    <p class="c4"><span class="c2">ECDH-ECDSA-DES-CBC3-SHA</span></p>
    <p class="c4"><span class="c2">AES128-GCM-SHA256</span></p>
    <p class="c4"><span class="c2">AES256-GCM-SHA384</span></p>
    <p class="c4"><span class="c2">DHE-RSA-AES128-GCM-SHA256</span></p>
    <p class="c4"><span class="c2">DHE-RSA-AES256-GCM-SHA384</span></p>
    <p class="c4"><span class="c2">ECDHE-RSA-AES128-GCM-SHA256</span></p>
    <p class="c4"><span class="c2">ECDHE-RSA-AES256-GCM-SHA384</span></p>
    <p class="c4"><span class="c2">ECDHE-ECDSA-AES128-GCM-SHA256</span></p>
    <p class="c4"><span class="c2">ECDHE-ECDSA-AES256-GCM-SHA384</span></p>
    <p class="c4"><span class="c2">ECDH-RSA-AES128-GCM-SHA256</span></p>
    <p class="c4"><span class="c2">ECDH-RSA-AES256-GCM-SHA384</span></p>
    <p class="c4"><span class="c2">ECDH-ECDSA-AES128-GCM-SHA256</span></p>
    <p class="c4"><span class="c2">ECDH-ECDSA-AES256-GCM-SHA384</span></p>
    <p class="c4"><span class="c2">CAMELLIA128-SHA</span></p>
    <p class="c4"><span class="c2">DHE-RSA-CAMELLIA128-SHA</span></p>
    <p class="c4"><span class="c2">CAMELLIA256-SHA</span></p>
    <p class="c4"><span class="c2">DHE-RSA-CAMELLIA256-SHA</span></p>
    <p class="c4"><span class="c2">CAMELLIA128-SHA256</span></p>
    <p class="c4"><span class="c2">DHE-RSA-CAMELLIA128-SHA256</span></p>
    <p class="c4"><span class="c2">CAMELLIA256-SHA256</span></p>
    <p class="c4"><span class="c2">DHE-RSA-CAMELLIA256-SHA256</span></p>
    <p class="c4"><span class="c2">ECDHE-RSA-AES128-SHA256</span></p>
    <p class="c4"><span class="c2">ECDHE-ECDSA-AES128-SHA256</span></p>
    <p class="c4"><span class="c2">ECDH-RSA-AES128-SHA256</span></p>
    <p class="c4"><span class="c2">ECDH-ECDSA-AES128-SHA256</span></p>
    <p class="c4"><span class="c2">ECDHE-ECDSA-AES256-SHA384</span></p>
    <p class="c4"><span class="c2">ECDH-RSA-AES256-SHA384</span></p>
    <p class="c4"><span class="c2">ECDH-ECDSA-AES256-SHA384</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_SUCCESS</span><span class="c2">&nbsp;will be returned upon successful function completion, otherwise </span><span class="c2 c3">SSL_FAILURE</span><span class="c2">&nbsp;will be returned on failure.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">list</span><span class="c2">&nbsp;- null-terminated text string and a colon-delimited list of cipher suites to use with the specified SSL session.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_set_cipher_list(ssl,</span></p>
    <p class="c4"><span class="c0">&ldquo;DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:AES256-SHA256&rdquo;);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// failed to set cipher suite list</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_set_cipher_list</span></p>
    <p class="c4"><span class="c2">wolfSSL_new</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.guoppun2z8ig"></a><span>wolfSSL_CTX_set_cipher_list</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">int &nbsp;wolfSSL_CTX_set_cipher_list(WOLFSSL_CTX* ctx, const char* list);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function sets cipher suite list for a given WOLFSSL_CTX. &nbsp;This cipher suite list becomes the default list for any new SSL sessions (WOLFSSL) created using this context. &nbsp;The ciphers in the list should be sorted in order of preference from highest to lowest. &nbsp;Each call to wolfSSL_CTX_set_cipher_list() resets the cipher suite list for the specific SSL context to the provided list each time the function is called.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The cipher suite list, </span><span class="c2 c3">list</span><span class="c2">, is a null-terminated text string, and a colon-delimited list. &nbsp;For example, one value for </span><span class="c2 c3">list</span><span class="c2">&nbsp;may be</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">&quot;DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:AES256-SHA256&quot;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">Valid cipher values are the full name values from the cipher_names[] array in src/internal.c:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">RC4-SHA</span></p>
    <p class="c4"><span class="c2">RC4-MD5</span></p>
    <p class="c4"><span class="c2">DES-CBC3-SHA</span></p>
    <p class="c4"><span class="c2">AES128-SHA</span></p>
    <p class="c4"><span class="c2">AES256-SHA</span></p>
    <p class="c4"><span class="c2">NULL-SHA</span></p>
    <p class="c4"><span class="c2">NULL-SHA256</span></p>
    <p class="c4"><span class="c2">DHE-RSA-AES128-SHA</span></p>
    <p class="c4"><span class="c2">DHE-RSA-AES256-SHA</span></p>
    <p class="c4"><span class="c2">PSK-AES128-CBC-SHA256</span></p>
    <p class="c4"><span class="c2">PSK-AES128-CBC-SHA</span></p>
    <p class="c4"><span class="c2">PSK-AES256-CBC-SHA</span></p>
    <p class="c4"><span class="c2">PSK-NULL-SHA256</span></p>
    <p class="c4"><span class="c2">PSK-NULL-SHA</span></p>
    <p class="c4"><span class="c2">HC128-MD5</span></p>
    <p class="c4"><span class="c2">HC128-SHA</span></p>
    <p class="c4"><span class="c2">HC128-B2B256</span></p>
    <p class="c4"><span class="c2">AES128-B2B256</span></p>
    <p class="c4"><span class="c2">AES256-B2B256</span></p>
    <p class="c4"><span class="c2">RABBIT-SHA</span></p>
    <p class="c4"><span class="c2">NTRU-RC4-SHA</span></p>
    <p class="c4"><span class="c2">NTRU-DES-CBC3-SHA</span></p>
    <p class="c4"><span class="c2">NTRU-AES128-SHA</span></p>
    <p class="c4"><span class="c2">NTRU-AES256-SHA</span></p>
    <p class="c4"><span class="c2">AES128-CCM-8</span></p>
    <p class="c4"><span class="c2">AES256-CCM-8</span></p>
    <p class="c4"><span class="c2">ECDHE-ECDSA-AES128-CCM-8</span></p>
    <p class="c4"><span class="c2">ECDHE-ECDSA-AES256-CCM-8</span></p>
    <p class="c4"><span class="c2">ECDHE-RSA-AES128-SHA</span></p>
    <p class="c4"><span class="c2">ECDHE-RSA-AES256-SHA</span></p>
    <p class="c4"><span class="c2">ECDHE-ECDSA-AES128-SHA</span></p>
    <p class="c4"><span class="c2">ECDHE-ECDSA-AES256-SHA</span></p>
    <p class="c4"><span class="c2">ECDHE-RSA-RC4-SHA</span></p>
    <p class="c4"><span class="c2">ECDHE-RSA-DES-CBC3-SHA</span></p>
    <p class="c4"><span class="c2">ECDHE-ECDSA-RC4-SHA</span></p>
    <p class="c4"><span class="c2">ECDHE-ECDSA-DES-CBC3-SHA</span></p>
    <p class="c4"><span class="c2">AES128-SHA256</span></p>
    <p class="c4"><span class="c2">AES256-SHA256</span></p>
    <p class="c4"><span class="c2">DHE-RSA-AES128-SHA256</span></p>
    <p class="c4"><span class="c2">DHE-RSA-AES256-SHA256</span></p>
    <p class="c4"><span class="c2">ECDH-RSA-AES128-SHA</span></p>
    <p class="c4"><span class="c2">ECDH-RSA-AES256-SHA</span></p>
    <p class="c4"><span class="c2">ECDH-ECDSA-AES128-SHA</span></p>
    <p class="c4"><span class="c2">ECDH-ECDSA-AES256-SHA</span></p>
    <p class="c4"><span class="c2">ECDH-RSA-RC4-SHA</span></p>
    <p class="c4"><span class="c2">ECDH-RSA-DES-CBC3-SHA</span></p>
    <p class="c4"><span class="c2">ECDH-ECDSA-RC4-SHA</span></p>
    <p class="c4"><span class="c2">ECDH-ECDSA-DES-CBC3-SHA</span></p>
    <p class="c4"><span class="c2">AES128-GCM-SHA256</span></p>
    <p class="c4"><span class="c2">AES256-GCM-SHA384</span></p>
    <p class="c4"><span class="c2">DHE-RSA-AES128-GCM-SHA256</span></p>
    <p class="c4"><span class="c2">DHE-RSA-AES256-GCM-SHA384</span></p>
    <p class="c4"><span class="c2">ECDHE-RSA-AES128-GCM-SHA256</span></p>
    <p class="c4"><span class="c2">ECDHE-RSA-AES256-GCM-SHA384</span></p>
    <p class="c4"><span class="c2">ECDHE-ECDSA-AES128-GCM-SHA256</span></p>
    <p class="c4"><span class="c2">ECDHE-ECDSA-AES256-GCM-SHA384</span></p>
    <p class="c4"><span class="c2">ECDH-RSA-AES128-GCM-SHA256</span></p>
    <p class="c4"><span class="c2">ECDH-RSA-AES256-GCM-SHA384</span></p>
    <p class="c4"><span class="c2">ECDH-ECDSA-AES128-GCM-SHA256</span></p>
    <p class="c4"><span class="c2">ECDH-ECDSA-AES256-GCM-SHA384</span></p>
    <p class="c4"><span class="c2">CAMELLIA128-SHA</span></p>
    <p class="c4"><span class="c2">DHE-RSA-CAMELLIA128-SHA</span></p>
    <p class="c4"><span class="c2">CAMELLIA256-SHA</span></p>
    <p class="c4"><span class="c2">DHE-RSA-CAMELLIA256-SHA</span></p>
    <p class="c4"><span class="c2">CAMELLIA128-SHA256</span></p>
    <p class="c4"><span class="c2">DHE-RSA-CAMELLIA128-SHA256</span></p>
    <p class="c4"><span class="c2">CAMELLIA256-SHA256</span></p>
    <p class="c4"><span class="c2">DHE-RSA-CAMELLIA256-SHA256</span></p>
    <p class="c4"><span class="c2">ECDHE-RSA-AES128-SHA256</span></p>
    <p class="c4"><span class="c2">ECDHE-ECDSA-AES128-SHA256</span></p>
    <p class="c4"><span class="c2">ECDH-RSA-AES128-SHA256</span></p>
    <p class="c4"><span class="c2">ECDH-ECDSA-AES128-SHA256</span></p>
    <p class="c4"><span class="c2">ECDHE-ECDSA-AES256-SHA384</span></p>
    <p class="c4"><span class="c2">ECDH-RSA-AES256-SHA384</span></p>
    <p class="c4"><span class="c2">ECDH-ECDSA-AES256-SHA384</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_SUCCESS</span><span class="c2">&nbsp;will be returned upon successful function completion, otherwise </span><span class="c2 c3">SSL_FAILURE</span><span class="c2">&nbsp;will be returned on failure.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx </span><span class="c2">- pointer to the SSL context, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">list</span><span class="c2">&nbsp;- null-terminated text string and a colon-delimited list of cipher suites to use with the specified SSL context.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CTX_set_cipher_list(ctx,</span></p>
    <p class="c4"><span class="c0">&ldquo;DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:AES256-SHA256&rdquo;);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// failed to set cipher suite list</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_set_cipher_list</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.qz5k57yop2nl"></a><span>wolfSSL_set_compression</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_set_compression(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Turns on the ability to use compression for the SSL connection. &nbsp;Both sides must have compression turned on otherwise compression will not be used. &nbsp;The zlib library performs the actual data compression. &nbsp;To compile into the library use --with-libz for the configure system and define HAVE_LIBZ otherwise.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">Keep in mind that while compressing data before sending decreases the actual size of the messages being sent and received, the amount of data saved by compression usually takes longer in time to analyze than it does to send it raw on all but the slowest of networks.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return SSL_SUCCESS.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NOT_COMPILED_IN</span><span class="c2">&nbsp;will be returned if compression support wasn&rsquo;t built into the library.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_set_compression(ssl);</span></p>
    <p class="c4"><span class="c0">if (ret == SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// successfully enabled compression for SSL session</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">NA</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.lxf2gktpv9x7"></a><span>wolfSSL_set_fd</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_set_fd(WOLFSSL* ssl, int fd);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function assigns a file descriptor (</span><span class="c2 c3">fd</span><span class="c2">) as the input/output facility for the SSL connection. &nbsp;Typically this will be a socket file descriptor.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">, otherwise, </span><span class="c2 c3">SSL_FAILURE</span><span class="c2">&nbsp;will be returned.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">fd</span><span class="c2">&nbsp;- file descriptor to use with SSL/TLS connection.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int sockfd;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_set_fd(ssl, sockfd);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// failed to set SSL file descriptor</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetIOSend</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetIORecv</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetIOReadCtx</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetIOWriteCtx</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.boxone6u3bo8"></a><span>wolfSSL_set_group_messages</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">int wolfSSL_set_group_messages(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function turns on grouping of handshake messages where possible.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_SUCCESS</span><span class="c2">&nbsp;will be returned upon success.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;will be returned if the input context is null.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_set_group_messages(ssl);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// failed to set handshake message grouping</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_set_group_messages</span></p>
    <p class="c4"><span class="c2">wolfSSL_new</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.2zk2h266izaj"></a><span>wolfSSL_CTX_set_group_messages</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">int wolfSSL_CTX_set_group_messages(WOLFSSL_CTX* ctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function turns on grouping of handshake messages where possible.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_SUCCESS</span><span class="c2">&nbsp;will be returned upon success.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;will be returned if the input context is null.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx </span><span class="c2">- pointer to the SSL context, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CTX_set_group_messages(ctx);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// failed to set handshake message grouping</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_set_group_messages</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.ifskml2t4qgu"></a><span>wolfSSL_set_session</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_set_session(WOLFSSL* ssl, WOLFSSL_SESSION* session);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function sets the session to be used when the SSL object, </span><span class="c2 c3">ssl</span><span class="c2">, is used to establish a SSL/TLS connection.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">For session resumption, before calling wolfSSL_shutdown() with your session object, an application should save the session ID from the object with a call to wolfSSL_get_session(), which returns a pointer to the session. &nbsp;Later, the application should create a new WOLFSSL object and assign the saved session with wolfSSL_set_session(). &nbsp;At this point, the application may call wolfSSL_connect() and wolfSSL will try to resume the session. &nbsp;The wolfSSL server code allows session resumption by default.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_SUCCESS</span><span class="c2">&nbsp;will be returned upon successfully setting the session.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FAILURE</span><span class="c2">&nbsp;will be returned on failure. &nbsp;This could be caused by the session cache being disabled, or if the session has timed out.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL object, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">session</span><span class="c2">&nbsp;- pointer to the WOLFSSL_SESSION used to set the session for </span><span class="c2 c3">ssl</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_SESSION* session;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_get_session(ssl, session);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// failed to set the SSL session</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_session</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.q4p7h03cnj8f"></a><span>wolfSSL_CTX_set_session_cache_mode</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">long wolfSSL_CTX_set_session_cache_mode(WOLFSSL_CTX* ctx, long mode);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function enables or disables SSL session caching. &nbsp;Behavior depends on the value used for </span><span class="c2 c3">mode</span><span class="c2">. &nbsp;The following values for </span><span class="c2 c3">mode</span><span class="c2">&nbsp;are available:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">SSL_SESS_CACHE_OFF</span></p>
    <p class="c4"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- disable session caching. &nbsp;Session caching is turned on by default.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">SSL_SESS_CACHE_NO_AUTO_CLEAR</span></p>
    <p class="c15 c4"><span class="c2">- Disable auto-flushing of the session cache. &nbsp;Auto-flushing is turned on by default.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_SUCCESS</span><span class="c2">&nbsp;will be returned upon success.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx </span><span class="c2">- pointer to the SSL context, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">mode</span><span class="c2">&nbsp;- modifier used to change behavior of the session cache.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_OFF);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// failed to turn SSL session caching off</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_flush_sessions</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_session</span></p>
    <p class="c4"><span class="c2">wolfSSL_set_session</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_sessionID</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_set_timeout</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.b83o2qg3g1zt"></a><span>wolfSSL_set_timeout</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_set_timeout(WOLFSSL* ssl, unsigned int to);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function sets the SSL session timeout value in seconds.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_SUCCESS</span><span class="c2">&nbsp;will be returned upon successfully setting the session.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;will be returned if </span><span class="c2 c3">ssl</span><span class="c2">&nbsp;is NULL.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL object, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">to</span><span class="c2">&nbsp;- value, in seconds, used to set the SSL session timeout.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_set_timeout(ssl, 500);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// failed to set session timeout value</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_session</span></p>
    <p class="c4"><span class="c2">wolfSSL_set_session</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.5qrcwcst3x2"></a><span>wolfSSL_CTX_set_timeout</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">int wolfSSL_CTX_set_timeout(WOLFSSL_CTX* ctx, unsigned int to);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function sets the timeout value for SSL sessions, in seconds, for the specified SSL context.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_SUCCESS</span><span class="c2">&nbsp;will be returned upon success.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;will be returned when the input context (</span><span class="c2 c3">ctx</span><span class="c2">) is null.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx </span><span class="c2">- pointer to the SSL context, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">to</span><span class="c2">&nbsp;- session timeout value in seconds</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* &nbsp; &nbsp;ctx &nbsp; &nbsp;= 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CTX_set_timeout(ctx, 500);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// failed to set session timeout value</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_flush_sessions</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_session</span></p>
    <p class="c4"><span class="c2">wolfSSL_set_session</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_sessionID</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_set_session_cache_mode</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.r96upvhk4qb6"></a><span>wolfSSL_set_using_nonblock</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_set_using_nonblock(WOLFSSL* ssl, int nonblock);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function informs the WOLFSSL object that the underlying I/O is non-blocking.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">After an application creates a WOLFSSL object, if it will be used with a non-blocking socket, call wolfSSL_set_using_nonblock() on it. This lets the WOLFSSL object know that receiving EWOULDBLOCK means that the recvfrom call would block rather than that it timed out.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2">This function does not have a return value.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">nonblock</span><span class="c2">&nbsp;- value used to set non-blocking flag on WOLFSSL object. &nbsp;Use 1 to specify non-blocking, otherwise 0.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">wolfSSL_set_using_nonblock(ssl, 1);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_using_nonblock</span></p>
    <p class="c4"><span class="c2">wolfSSL_dtls_got_timeout</span></p>
    <p class="c4"><span class="c2">wolfSSL_dtls_get_current_timeout</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.9nktkvhn2ona"></a><span>wolfSSL_set_verify</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_set_verify(WOLFSSL* ssl, int mode, VerifyCallback vc);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">typedef int (*VerifyCallback)(int, WOLFSSL_X509_STORE_CTX*);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function sets the verification method for remote peers and also allows a verify callback to be registered with the SSL session. &nbsp;The verify callback will be called only when a verification failure has occurred. &nbsp;If no verify callback is desired, the NULL pointer can be used for </span><span class="c2 c3">verify_callback</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The verification </span><span class="c2 c3">mode</span><span class="c2">&nbsp;of peer certificates is a logically OR&rsquo;d list of flags. &nbsp;The possible flag values include:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">SSL_VERIFY_NONE</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c17"><span class="c2 c3">Client mode</span><span class="c2">: &nbsp;the client will not verify the certificate received from the server and the handshake will continue as normal.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c17"><span class="c2 c3">Server mode</span><span class="c2">: &nbsp;the server will not send a certificate request to the client. &nbsp;As such, client verification will not be enabled.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">SSL_VERIFY_PEER</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c17"><span class="c2 c3">Client mode</span><span class="c2">: &nbsp;the client will verify the certificate received from the server during the handshake. &nbsp;This is turned on by default in wolfSSL, therefore, using this option has no effect.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c17"><span class="c2 c3">Server mode</span><span class="c2">: the server will send a certificate request to the client and verify the client certificate received.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">SSL_VERIFY_FAIL_IF_NO_PEER_CERT</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c17"><span class="c2 c3">Client mode</span><span class="c2">: &nbsp;no effect when used on the client side.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c17"><span class="c2 c3">Server mode</span><span class="c2">: &nbsp;the verification will fail on the server side if the client fails to send a certificate when requested to do so (when using SSL_VERIFY_PEER on the SSL server).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2">This function has no return value.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">mode</span><span class="c2">&nbsp;- session timeout value in seconds</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">verify_callback</span><span class="c2">&nbsp;- callback to be called when verification fails. &nbsp;If no callback is desired, the NULL pointer can be used for verify_callback.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">wolfSSL_set_verify(ssl, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, 0);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_set_verify</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.bagbsvfoacgd"></a><span>wolfSSL_CTX_set_verify</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">void wolfSSL_CTX_set_verify(WOLFSSL_CTX* ctx, int mode,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VerifyCallback vc);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">typedef int (*VerwolfSSL_ASN1_INTEGER_cmp</span></p>
    <p class="c4"><span class="c2">ifyCallback)(int, WOLFSSL_X509_STORE_CTX*);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function sets the verification method for remote peers and also allows a verify callback to be registered with the SSL context. &nbsp;The verify callback will be called only when a verification failure has occurred. &nbsp;If no verify callback is desired, the NULL pointer can be used for </span><span class="c2 c3">verify_callback</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The verification </span><span class="c2 c3">mode</span><span class="c2">&nbsp;of peer certificates is a logically OR&rsquo;d list of flags. &nbsp;The possible flag values include:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">SSL_VERIFY_NONE</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c17"><span class="c2 c3">Client mode</span><span class="c2">: &nbsp;the client will not verify the certificate received from the server and the handshake will continue as normal.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c17"><span class="c2 c3">Server mode</span><span class="c2">: &nbsp;the server will not send a certificate request to the client. &nbsp;As such, client verification will not be enabled.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">SSL_VERIFY_PEER</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c17"><span class="c2 c3">Client mode</span><span class="c2">: &nbsp;the client will verify the certificate received from the server during the handshake. &nbsp;This is turned on by default in wolfSSL, therefore, using this option has no effect.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c17"><span class="c2 c3">Server mode</span><span class="c2">: the server will send a certificate request to the client and verify the client certificate received.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">SSL_VERIFY_FAIL_IF_NO_PEER_CERT</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c17"><span class="c2 c3">Client mode</span><span class="c2">: &nbsp;no effect when used on the client side.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c17"><span class="c2 c3">Server mode</span><span class="c2">: &nbsp;the verification will fail on the server side if the client fails to send a certificate when requested to do so (when using SSL_VERIFY_PEER on the SSL server).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2">This function has no return value.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx </span><span class="c2">- pointer to the SSL context, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">mode</span><span class="c2">&nbsp;- session timeout value in seconds</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">verify_callback</span><span class="c2">&nbsp;- callback to be called when verification fails. &nbsp;If no callback is desired, the NULL pointer can be used for verify_callback.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* &nbsp; &nbsp;ctx &nbsp; &nbsp;= 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">wolfSSL_CTX_set_verify(ctx, SSL_VERIFY_PEER |</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SSL_VERIFY_FAIL_IF_NO_PEER_CERT, 0);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_set_verify</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h2 class="c4 c18"><a name="h.9552p39wvrhj"></a><span>17.4 Callbacks</span></h2>
    <hr>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The functions in this section have to do with callbacks which the application is able to set in relation to wolfSSL.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.7mivrbjjdc8a"></a><span>wolfSSL_SetIOReadCtx</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">void wolfSSL_SetIOReadCtx(WOLFSSL* ssl, void *rctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function registers a context for the SSL session&rsquo;s receive callback function. &nbsp;By default, wolfSSL sets the file descriptor passed to wolfSSL_set_fd() as the context when wolfSSL is using the system&rsquo;s TCP library. &nbsp;If you&rsquo;ve registered your own receive callback you may want to set a specific context for the session. &nbsp;For example, if you&rsquo;re using memory buffers the context may be a pointer to a structure describing where and how to access the memory buffers.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">No return values are used for this function.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">rctx</span><span class="c2">&nbsp;- pointer to the context to be registered with the SSL session&rsquo;s (</span><span class="c2 c3">ssl</span><span class="c2">) receive callback function.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int sockfd;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">// Manually setting the socket fd as the receive CTX, for example</span></p>
    <p class="c4"><span class="c0">wolfSSL_SetIOReadCtx(ssl, &amp;sockfd);</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetIORecv</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetIOSend</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetIOWriteCtx</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.d828pgwcp38r"></a><span>wolfSSL_SetIOWriteCtx</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">void wolfSSL_SetIOWriteCtx(WOLFSSL* ssl, void *wctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function registers a context for the SSL session&rsquo;s send callback function. &nbsp;By default, wolfSSL sets the file descriptor passed to wolfSSL_set_fd() as the context when wolfSSL is using the system&rsquo;s TCP library. &nbsp;If you&rsquo;ve registered your own send callback you may want to set a specific context for the session. &nbsp;For example, if you&rsquo;re using memory buffers the context may be a pointer to a structure describing where and how to access the memory buffers.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">No return values are used for this function.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">wctx</span><span class="c2">&nbsp;- pointer to the context to be registered with the SSL session&rsquo;s (</span><span class="c2 c3">ssl</span><span class="c2">) send callback function.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int sockfd;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">// Manually setting the socket fd as the send CTX, for example</span></p>
    <p class="c4"><span class="c0">wolfSSL_SetIOSendCtx(ssl, &amp;sockfd);</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetIORecv</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetIOSend</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetIOReadCtx</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.5ovrfntyal3a"></a><span>wolfSSL_SetIOReadFlags</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">void wolfSSL_SetIOReadFlags( WOLFSSL* ssl, int flags);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function sets the flags for the receive callback to use for the given SSL session. &nbsp;The receive callback could be either the default wolfSSL EmbedReceive callback, or a custom callback specified by the user (see &nbsp;wolfSSL_SetIORecv). The default flag value is set internally by wolfSSL to the value of 0. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The default wolfSSL receive callback uses the recv() function to receive data from the socket. &nbsp;From the recv() man page:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">&ldquo;The flags argument to a recv() function is formed by or&#39;ing one or more of the values:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c15 c4"><span class="c2">MSG_OOB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process out-of-band data</span></p>
    <p class="c15 c4"><span class="c2">MSG_PEEK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;peek at incoming message</span></p>
    <p class="c15 c4"><span class="c2">MSG_WAITALL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait for full request or error</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The MSG_OOB flag requests receipt of out-of-band data that would not be received in the normal data stream. &nbsp;Some protocols place expedited data at the head of the normal data queue, and thus this flag cannot be used with such protocols. &nbsp;The MSG_PEEK flag causes the receive operation to return data from the beginning of the receive queue without removing that data from the queue. &nbsp;Thus, a subsequent receive call will return the same data. &nbsp;The MSG_WAITALL flag requests that the operation block until the full request is satisfied. &nbsp;However, the call may still return less data than requested if a signal is caught, an error or disconnect occurs, or the next data to be received is of a different type than that returned.&rdquo;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">No return values are used for this function.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">flags</span><span class="c2">&nbsp;- value of the I/O read flags for the specified SSL session (</span><span class="c2 c3">ssl</span><span class="c2">).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">// Manually setting recv flags to 0</span></p>
    <p class="c4"><span class="c0">wolfSSL_SetIOReadFlags(ssl, 0);</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetIORecv</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetIOSend</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetIOReadCtx</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.pvzo5ba0177x"></a><span>wolfSSL_SetIOWriteFlags</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">void wolfSSL_SetIOWriteFlags( WOLFSSL* ssl, int flags);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function sets the flags for the send callback to use for the given SSL session. &nbsp;The send callback could be either the default wolfSSL EmbedSend callback, or a custom callback specified by the user (see &nbsp;wolfSSL_SetIOSend). The default flag value is set internally by wolfSSL to the value of 0. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The default wolfSSL send callback uses the send() function to send data from the socket. &nbsp;From the send() man page:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">&ldquo;The flags parameter may include one or more of the following:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c15 c4"><span class="c2">#define MSG_OOB &nbsp; &nbsp; &nbsp; &nbsp;0x1 &nbsp;/* process out-of-band data */</span></p>
    <p class="c15 c4"><span class="c2">#define MSG_DONTROUTE &nbsp;0x4 &nbsp;/* bypass routing, use direct interface */</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The flag MSG_OOB is used to send ``out-of-band&#39;&#39; data on sockets that support this notion (e.g. &nbsp;SOCK_STREAM); the underlying protocol must also support ``out-of-band&#39;&#39; data. &nbsp;MSG_DONTROUTE is usually used only by diagnostic or routing programs.&rdquo;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">No return values are used for this function.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">flags</span><span class="c2">&nbsp;- value of the I/O send flags for the specified SSL session (</span><span class="c2 c3">ssl</span><span class="c2">).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">// Manually setting send flags to 0</span></p>
    <p class="c4"><span class="c0">wolfSSL_SetIOSendFlags(ssl, 0);</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetIORecv</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetIOSend</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetIOReadCtx</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.46014ylme3u3"></a><span>wolfSSL_SetIORecv</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">void wolfSSL_SetIORecv(WOLFSSL_CTX* ctx, CallbackIORecv CBIORecv);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">typedef int (*CallbackIORecv)(char *buf, int sz, void *ctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function registers a receive callback for wolfSSL to get input data. &nbsp;By default, wolfSSL uses EmbedReceive() as the callback which uses the system&rsquo;s TCP recv() function. &nbsp;The user can register a function to get input from memory, some other network module, or from anywhere. &nbsp;Please see the EmbedReceive() function in </span><span class="c2 c3">src/io.c</span><span class="c2">&nbsp;as a guide for how the function should work and for error codes. &nbsp;In particular, </span><span class="c2 c3">IO_ERR_WANT_READ</span><span class="c2">&nbsp;should be returned for non blocking receive when no data is ready.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">No return values are used for this function.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx </span><span class="c2">- pointer to the SSL context, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">callback</span><span class="c2">&nbsp;- function to be registered as the receive callback for the wolfSSL context, </span><span class="c2 c3">ctx</span><span class="c2">. The signature of this function must follow that as shown above in the Synopsis section.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx = 0;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">// Receive callback prototype</span></p>
    <p class="c4"><span class="c0">int MyEmbedReceive(WOLFSSL *ssl, char *buf, int sz, void *ctx);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">// Register the custom receive callback with wolfSSL</span></p>
    <p class="c4"><span class="c0">wolfSSL_SetIORecv(ctx, MyEmbedReceive);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">int MyEmbedReceive(WOLFSSL *ssl, char *buf, int sz, void *ctx) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p>
    <p class="c4"><span class="c0">{</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// custom EmbedReceive function</span></p>
    <p class="c4"><span class="c0">} &nbsp;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetIOSend</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetIOReadCtx</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetIOWriteCtx</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.5q9uk8qahej"></a><span>wolfSSL_SetIOSend</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">void wolfSSL_SetIOSend(WOLFSSL_CTX* ctx, CallbackIOSend CBIOSend);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">typedef int (*CallbackIOSend)(char *buf, int sz, void *ctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function registers a send callback for wolfSSL to write output data. &nbsp;By default, wolfSSL uses EmbedSend() as the callback which uses the system&rsquo;s TCP send() function. &nbsp;The user can register a function to send output to memory, some other network module, or to anywhere. &nbsp;Please see the EmbedSend() function in </span><span class="c2 c3">src/io.c</span><span class="c2">&nbsp;as a guide for how the function should work and for error codes. &nbsp;In particular, </span><span class="c2 c3">IO_ERR_WANT_WRITE</span><span class="c2">&nbsp;should be returned for non blocking send when the action cannot be taken yet.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">No return values are used for this function.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx </span><span class="c2">- pointer to the SSL context, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">callback</span><span class="c2">&nbsp;- function to be registered as the send callback for the wolfSSL context, </span><span class="c2 c3">ctx</span><span class="c2">. The signature of this function must follow that as shown above in the Synopsis section.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx = 0;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">// Receive callback prototype</span></p>
    <p class="c4"><span class="c0">int MyEmbedSend(WOLFSSL *ssl, char *buf, int sz, void *ctx);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">// Register the custom receive callback with wolfSSL</span></p>
    <p class="c4"><span class="c0">wolfSSL_SetIOSend(ctx, MyEmbedSend);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">int MyEmbedSend(WOLFSSL *ssl, char *buf, int sz, void *ctx) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p>
    <p class="c4"><span class="c0">{</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// custom EmbedSend function</span></p>
    <p class="c4"><span class="c0">} &nbsp;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetIORecv</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetIOReadCtx</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetIOWriteCtx</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5 c19"><span class="c2 c3"></span></p>
    <h3 class="c7 c4"><a name="h.vbar1z5cbrmg"></a><span>wolfSSL_CTX_set_TicketEncCb</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">typedef int (*SessionTicketEncCb)(WOLFSSL*,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;unsigned char key_name[WOLFSSL_TICKET_NAME_SZ],</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;unsigned char iv[WOLFSSL_TICKET_IV_SZ],</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;unsigned char mac[WOLFSSL_TICKET_MAC_SZ],</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int enc, unsigned char* ticket, int inLen, int* outLen);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_CTX_set_TicketEncCb(WOLFSSL_CTX* ctx, SessionTicketEncCb);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function sets the session ticket key encrypt callback function for a server to support session tickets as specified in RFC 5077. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c2 c6"></span></p>
    <p class="c4"><span class="c2 c3">SSL_SUCCESS</span><span class="c2">&nbsp;will be returned upon successfully setting the session.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;will be returned on failure. &nbsp;This is caused by passing invalid arguments to the function. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx </span><span class="c2">- pointer to the WOLFSSL_CTX object, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">cb</span><span class="c2">&nbsp;- user callback function to encrypt/decrypt session tickets</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Callback Parameters:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- pointer to the WOLFSSL object, created with wolfSSL_new()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">key_name </span><span class="c2">- unique key name for this ticket context, should be randomly generated</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">iv</span><span class="c2">&nbsp;- unique IV for this ticket, up to 128 bits, should be randomly generated</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">mac</span><span class="c2">&nbsp;- up to 256 bit mac for this ticket</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">enc</span><span class="c2">&nbsp;- if this encrypt parameter is true the user should fill in key_name, iv, mac, and encrypt the ticket in-place of length inLen and set the resulting output length in *outLen. &nbsp;Returning WOLFSSL_TICKET_RET_OK tells wolfSSL that the encryption was successful. &nbsp;If this encrypt parameter is false, the user should perform a decrypt of the ticket in-place of length inLen using key_name, iv, and mac. &nbsp;The resulting decrypt length should be set in *outLen. &nbsp;Returning WOLFSSL_TICKET_RET_OK tells wolfSSL to proceed using the decrypted ticket. &nbsp;Returning WOLFSSL_TICKET_RET_CREATE tells wolfSSL to use the decrypted ticket but also to generate a new one to send to the client, helpful if recently rolled keys and don&rsquo;t want to force a full handshake. &nbsp;Returning WOLFSSL_TICKET_RET_REJECT tells wolfSSL to reject this ticket, perform a full handshake, and create a new standard session ID for normal session resumption. &nbsp;Returning WOLFSSL_TICKET_RET_FATAL tells wolfSSL to end the connection attempt with a fatal error.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ticket</span><span class="c2">&nbsp;- the input/output buffer for the encrypted ticket. &nbsp;See the enc parameter</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">inLen</span><span class="c2">&nbsp;- the input length of the ticket parameter</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">outLen</span><span class="c2">&nbsp;- the resulting output length of the ticket parameter</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">See wolfssl/test.h myTicketEncCb() used by the example server and example echoserver.</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_set_TicketHint</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.idue3tkqwm3w"></a><span>wolfSSL_CTX_set_TicketHint</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_CTX_set_TicketHint(WOLFSSL_CTX* ctx, int hint);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function sets the session ticket hint relayed to the client. &nbsp;For server side use.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_SUCCESS</span><span class="c2">&nbsp;will be returned upon successfully setting the session.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;will be returned on failure. &nbsp;This is caused by passing invalid arguments to the function. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx </span><span class="c2">- pointer to the WOLFSSL_CTX object, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">hint </span><span class="c2">- number of seconds the ticket might be valid for. &nbsp;Hint to client.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_set_TicketEncCb()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5 c19"><span class="c2 c3"></span></p>
    <p class="c4 c5 c19"><span class="c2 c3"></span></p>
    <h3 class="c7 c4"><a name="h.kaosw6ufkrhn"></a><span>wolfSSL_CTX_SetCACb</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">void wolfSSL_CTX_SetCACb(WOLFSSL_CTX* ctx, CallbackCACache cb);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">typedef void (*CallbackCACache)(unsigned char* der, int sz, int type);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function registers a callback with the SSL context (WOLFSSL_CTX) to be called when a new CA certificate is loaded into wolfSSL. &nbsp;The callback is given a buffer with the DER-encoded certificate.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">This function has no return value.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx </span><span class="c2">- pointer to the SSL context, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">callback</span><span class="c2">&nbsp;- function to be registered as the CA callback for the wolfSSL context, </span><span class="c2 c3">ctx</span><span class="c2">. The signature of this function must follow that as shown above in the Synopsis section.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx = 0;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">// CA callback prototype</span></p>
    <p class="c4"><span class="c0">int MyCACallback(unsigned char *der, int sz, int type);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">// Register the custom CA callback with the SSL context</span></p>
    <p class="c4"><span class="c0">wolfSSL_CTX_SetCACb(ctx, MyCACallback);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">int MyCACallback(unsigned char* der, int sz, int type) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p>
    <p class="c4"><span class="c0">{</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* custom CA callback function, DER-encoded cert</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; located in &ldquo;der&rdquo; of size &ldquo;sz&rdquo; with type &ldquo;type&rdquo; */</span></p>
    <p class="c4"><span class="c0">} &nbsp;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_load_verify_locations</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.76ckknskgmmk"></a><span>wolfSSL_connect_ex</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_connect_ex(WOLFSSL* ssl, HandShakeCallBack hsCb,</span></p>
    <p class="c4 c22"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; TimeoutCallBack toCb, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Timeval timeout);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">typedef int (*HandShakeCallBack)(HandShakeInfo*);</span></p>
    <p class="c4"><span class="c2">typedef int (*TimeoutCallBack)(TimeoutInfo*);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">typedef struct timeval Timeval;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c11 c2">typedef struct handShakeInfo_st {</span></p>
    <p class="c15 c4"><span class="c11 c2">char &nbsp; cipherName[MAX_CIPHERNAME_SZ + 1]; &nbsp;/* negotiated name */</span></p>
    <p class="c15 c4"><span class="c11 c2">char &nbsp; packetNames[MAX_PACKETS_HANDSHAKE][MAX_PACKETNAME_SZ+1];</span></p>
    <p class="c15 c4"><span class="c11 c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* SSL packet names */</span></p>
    <p class="c15 c4"><span class="c11 c2">int &nbsp; &nbsp;numberPackets; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* actual # of packets &nbsp;*/</span></p>
    <p class="c15 c4"><span class="c11 c2">int &nbsp; &nbsp;negotiationError; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* cipher/parameter err */</span></p>
    <p class="c4"><span class="c11 c2">} HandShakeInfo;</span></p>
    <p class="c4 c5"><span class="c11 c2"></span></p>
    <p class="c4 c5"><span class="c11 c2"></span></p>
    <p class="c4"><span class="c11 c2">typedef struct timeoutInfo_st {</span></p>
    <p class="c15 c4"><span class="c11 c2">char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeoutName[MAX_TIMEOUT_NAME_SZ +1]; /*timeout Name*/</span></p>
    <p class="c15 c4"><span class="c11 c2">int &nbsp; &nbsp; &nbsp; &nbsp;flags; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* for future use*/</span></p>
    <p class="c15 c4"><span class="c11 c2">int &nbsp; &nbsp; &nbsp; &nbsp;numberPackets; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* actual # of packets */</span></p>
    <p class="c15 c4"><span class="c11 c2">PacketInfo packets[MAX_PACKETS_HANDSHAKE]; /* list of packets */</span></p>
    <p class="c15 c4"><span class="c11 c2">Timeval &nbsp; &nbsp;timeoutValue; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* timer that caused it */</span></p>
    <p class="c4"><span class="c11 c2">} TimeoutInfo;</span></p>
    <p class="c4 c5"><span class="c11 c2"></span></p>
    <p class="c4 c5"><span class="c11 c2"></span></p>
    <p class="c4"><span class="c11 c2">typedef struct packetInfo_st {</span></p>
    <p class="c4"><span class="c11 c2">&nbsp; &nbsp; &nbsp;char &nbsp; &nbsp; &nbsp; &nbsp;packetName[MAX_PACKETNAME_SZ + 1]; /* SSL name */</span></p>
    <p class="c4"><span class="c11 c2">&nbsp; &nbsp; &nbsp;Timeval &nbsp; &nbsp; timestamp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* when it occured&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></p>
    <p class="c4"><span class="c11 c2">&nbsp; &nbsp; &nbsp;unsigned char value[MAX_VALUE_SZ]; &nbsp; /* if fits, it&#39;s here */</span></p>
    <p class="c4"><span class="c11 c2">&nbsp; &nbsp; &nbsp;unsigned char* bufferValue; &nbsp; &nbsp; &nbsp; /* otherwise here (non 0) */</span></p>
    <p class="c4"><span class="c11 c2">&nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; &nbsp; &nbsp; valueSz; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* sz of value or buffer */</span></p>
    <p class="c4"><span class="c11 c2">} PacketInfo;</span></p>
    <p class="c4 c5"><span class="c11 c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">wolfSSL_connect_ex() is an extension that allows a HandShake Callback to be set. &nbsp;This can be useful in embedded systems for debugging support when a debugger isn&rsquo;t available and sniffing is impractical. &nbsp;The HandShake Callback will be called whether or not a handshake error occurred. &nbsp;No dynamic memory is used since the maximum number of SSL packets is known. &nbsp;Packet names can be accessed through </span><span class="c2 c3">packetNames[]</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The connect extension also allows a Timeout Callback to be set along with a timeout value. &nbsp;This is useful if the user doesn&rsquo;t want to wait for the TCP stack to timeout.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">This extension can be called with either, both, or neither callbacks.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">GETTIME_ERROR</span><span class="c2">&nbsp;will be returned if </span><span class="c2 c16">gettimeofday()</span><span class="c2">&nbsp;encountered an error.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SETITIMER_ERROR</span><span class="c2">&nbsp;will be returned if </span><span class="c2 c16">setitimer()</span><span class="c2">&nbsp;encountered an error.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SIGACT_ERROR</span><span class="c2">&nbsp;will be returned if </span><span class="c2 c16">sigaction()</span><span class="c2">&nbsp;encountered an error.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FATAL_ERROR</span><span class="c2">&nbsp;will be returned if the underlying </span><span class="c2 c16">SSL_connect()</span><span class="c2">&nbsp;call encountered an error.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_accept_ex</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.x9trcbj7cyyb"></a><span>wolfSSL_accept_ex</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_accept_ex(WOLFSSL* ssl, HandShakeCallBack hsCb,</span></p>
    <p class="c12 c4"><span class="c2">&nbsp; &nbsp; &nbsp;TimeoutCallBack toCb, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Timeval timeout);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">typedef int (*HandShakeCallBack)(HandShakeInfo*);</span></p>
    <p class="c4"><span class="c2">typedef int (*TimeoutCallBack)(TimeoutInfo*);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">typedef struct timeval Timeval;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c11">typedef struct handShakeInfo_st {</span></p>
    <p class="c15 c4"><span class="c11 c2">char &nbsp; cipherName[MAX_CIPHERNAME_SZ + 1]; &nbsp;/* negotiated name */</span></p>
    <p class="c15 c4"><span class="c11 c2">char &nbsp; packetNames[MAX_PACKETS_HANDSHAKE][MAX_PACKETNAME_SZ+1];</span></p>
    <p class="c15 c4"><span class="c11 c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* SSL packet names */</span></p>
    <p class="c15 c4"><span class="c11 c2">int &nbsp; &nbsp;numberPackets; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* actual # of packets &nbsp;*/</span></p>
    <p class="c15 c4"><span class="c11 c2">int &nbsp; &nbsp;negotiationError; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* cipher/parameter err */</span></p>
    <p class="c4"><span class="c11 c2">} HandShakeInfo;</span></p>
    <p class="c4 c5"><span class="c11 c2"></span></p>
    <p class="c4 c5"><span class="c11 c2"></span></p>
    <p class="c4"><span class="c11 c2">typedef struct timeoutInfo_st {</span></p>
    <p class="c15 c4"><span class="c11 c2">char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeoutName[MAX_TIMEOUT_NAME_SZ +1]; /*timeout Name*/</span></p>
    <p class="c15 c4"><span class="c11 c2">int &nbsp; &nbsp; &nbsp; &nbsp;flags; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* for future use*/</span></p>
    <p class="c15 c4"><span class="c11 c2">int &nbsp; &nbsp; &nbsp; &nbsp;numberPackets; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* actual # of packets */</span></p>
    <p class="c15 c4"><span class="c11 c2">PacketInfo packets[MAX_PACKETS_HANDSHAKE]; /* list of packets */</span></p>
    <p class="c15 c4"><span class="c11 c2">Timeval &nbsp; &nbsp;timeoutValue; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* timer that caused it */</span></p>
    <p class="c4"><span class="c11 c2">} TimeoutInfo;</span></p>
    <p class="c4 c5"><span class="c11 c2"></span></p>
    <p class="c4 c5"><span class="c11 c2"></span></p>
    <p class="c4"><span class="c11 c2">typedef struct packetInfo_st {</span></p>
    <p class="c4"><span class="c11 c2">&nbsp; &nbsp; &nbsp;char &nbsp; &nbsp; &nbsp; &nbsp;packetName[MAX_PACKETNAME_SZ + 1]; /* SSL name */</span></p>
    <p class="c4"><span class="c11 c2">&nbsp; &nbsp; &nbsp;Timeval &nbsp; &nbsp; timestamp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* when it occured&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></p>
    <p class="c4"><span class="c11 c2">&nbsp; &nbsp; &nbsp;unsigned char value[MAX_VALUE_SZ]; &nbsp; /* if fits, it&#39;s here */</span></p>
    <p class="c4"><span class="c11 c2">&nbsp; &nbsp; &nbsp;unsigned char* bufferValue; &nbsp; &nbsp; &nbsp; /* otherwise here (non 0) */</span></p>
    <p class="c4"><span class="c11 c2">&nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; &nbsp; &nbsp; valueSz; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* sz of value or buffer */</span></p>
    <p class="c4"><span class="c11 c2">} PacketInfo;</span></p>
    <p class="c4 c5"><span class="c11 c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">wolfSSL_accept_ex() is an extension that allows a HandShake Callback to be set. &nbsp;This can be useful in embedded systems for debugging support when a debugger isn&rsquo;t available and sniffing is impractical. &nbsp;The HandShake Callback will be called whether or not a handshake error occurred. &nbsp;No dynamic memory is used since the maximum number of SSL packets is known. &nbsp;Packet names can be accessed through </span><span class="c2 c3">packetNames[]</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The connect extension also allows a Timeout Callback to be set along with a timeout value. &nbsp;This is useful if the user doesn&rsquo;t want to wait for the TCP stack to timeout.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">This extension can be called with either, both, or neither callbacks.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">GETTIME_ERROR</span><span class="c2">&nbsp;will be returned if </span><span class="c2 c16">gettimeofday()</span><span class="c2">&nbsp;encountered an error.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SETITIMER_ERROR</span><span class="c2">&nbsp;will be returned if </span><span class="c2 c16">setitimer()</span><span class="c2">&nbsp;encountered an error.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SIGACT_ERROR</span><span class="c2">&nbsp;will be returned if </span><span class="c2 c16">sigaction()</span><span class="c2">&nbsp;encountered an error.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FATAL_ERROR</span><span class="c2">&nbsp;will be returned if the underlying </span><span class="c2 c16">SSL_accept()</span><span class="c2">&nbsp;call encountered an error.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_connect_ex</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.fa5moasone3n"></a><span>wolfSSL_SetLoggingCb</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/wolfcrypt/logging.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_SetLoggingCb(wolfSSL_Logging_cb log_function);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">typedef void (*wolfSSL_Logging_cb)(const int logLevel, const char *const logMessage);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function registers a logging callback that will be used to handle the wolfSSL log message. &nbsp;By default, if the system supports it </span><span class="c2 c16">fprintf()</span><span class="c2">&nbsp;to </span><span class="c2 c3">stderr</span><span class="c2">&nbsp;is used but by using this function anything can be done by the user.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful this function will return 0.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;is the error that will be returned if a function pointer is not provided.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">log_function</span><span class="c2">&nbsp;- function to register as a logging callback. &nbsp;Function signature must follow the above prototype.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">// Logging callback prototype</span></p>
    <p class="c4"><span class="c0">void MyLoggingCallback(const int logLevel, const char* const logMessage);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">// Register the custom logging callback with wolfSSL</span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_SetLoggingCb(myLogCallback);</span></p>
    <p class="c4"><span class="c0">if (ret != 0) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// failed to set logging callback</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">void MyLoggingCallback(const int logLevel, const char* const logMessage)</span></p>
    <p class="c4"><span class="c0">{</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// custom logging function</span></p>
    <p class="c4"><span class="c0">} &nbsp;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_Debugging_ON</span></p>
    <p class="c4"><span class="c2">wolfSSL_Debugging_OFF</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.pocvebv0roxd"></a><span>wolfSSL_SetTlsHmacInner</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_SetTlsHmacInner(WOLFSSL* ssl, byte* inner, word32 sz,</span></p>
    <p class="c4 c23"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;int content, int verify);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to set the Hmac Inner vector for message sending/receiving. &nbsp;The result is written to </span><span class="c2 c3">inner</span><span class="c2">&nbsp;which should be at least wolfSSL_GetHmacSize() bytes. &nbsp;The size of the message is specified by </span><span class="c2 c3">sz</span><span class="c2">, </span><span class="c2 c3">content</span><span class="c2">&nbsp;is the type of message, and </span><span class="c2 c3">verify</span><span class="c2">&nbsp;specifies whether this is a verification of a peer message. Valid for cipher types excluding </span><span class="c2 c3">WOLFSSL_AEAD_TYPE</span><span class="c2">. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return 1.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;will be returned for an error state.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetBulkCipher()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetHmacType()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.w5hbqpiucveb"></a><span>wolfSSL_CTX_SetMacEncryptCb</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_CTX_SetMacEncryptCb(WOLFSSL_CTX*, CallbackMacEncrypt);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">typedef int (*CallbackMacEncrypt)(WOLFSSL* ssl, unsigned char* macOut,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;const unsigned char* macIn, unsigned int macInSz, int macContent,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;int macVerify, unsigned char* encOut, const unsigned char* encIn,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;unsigned int encSz, void* ctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to set the Atomic User Record Processing Mac/Encrypt Callback. &nbsp;The callback should return 0 for success or &lt; 0 for an error. &nbsp;The </span><span class="c2 c3">ssl</span><span class="c2">&nbsp;and </span><span class="c2 c3">ctx</span><span class="c2">&nbsp;pointers are available for the users convenience. &nbsp;</span><span class="c2 c3">macOut</span><span class="c2">&nbsp;is the output buffer where the result of the mac should be stored. &nbsp;</span><span class="c2 c3">macIn</span><span class="c2">&nbsp;is the mac input buffer and </span><span class="c2 c3">macInSz</span><span class="c2">&nbsp;notes the size of the buffer. &nbsp;</span><span class="c2 c3">macContent</span><span class="c2">&nbsp;and </span><span class="c2 c3">macVerify</span><span class="c2">&nbsp;are needed for wolfSSL_SetTlsHmacInner() and be passed along as is. &nbsp;</span><span class="c2 c3">encOut</span><span class="c2">&nbsp;is the output buffer where the result on the encryption should be stored. &nbsp;</span><span class="c2 c3">encIn</span><span class="c2">&nbsp;is the input buffer to encrypt while </span><span class="c2 c3">encSz</span><span class="c2">&nbsp;is the size of the input. &nbsp;An example callback can be found wolfssl/test.h myMacEncryptCb().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">NA</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetMacEncryptCtx()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetMacEncryptCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.y2wkq7am05ba"></a><span>wolfSSL_SetMacEncryptCtx</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_SetMacEncryptCtx(WOLFSSL*, void* ctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to set the Atomic User Record Processing Mac/Encrypt Callback Context to </span><span class="c2 c3">ctx</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">NA</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_SetMacEncryptCb()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetMacEncryptCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.tr204u3qimf4"></a><span>wolfSSL_GetMacEncryptCtx</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void* wolfSSL_GetMacEncryptCtx(WOLFSSL*);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to retrieve the Atomic User Record Processing Mac/Encrypt Callback Context previously stored with wolfSSL_SetMacEncryptCtx().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return a valid pointer to the context.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NULL</span><span class="c2">&nbsp;will be returned for a blank context.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_SetMacEncryptCb()</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetMacEncryptCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.b4eajvor6e2k"></a><span>wolfSSL_CTX_SetDecryptVerifyCb</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_CTX_SetDecryptVerifyCb(WOLFSSL_CTX*, CallbackDecryptVerify);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">typedef int (*CallbackDecryptVerify)(WOLFSSL* ssl,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;unsigned char* decOut, const unsigned char* decIn,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;unsigned int decSz, int content, int verify, unsigned int* padSz,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;void* ctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to set the Atomic User Record Processing Decrypt/Verify Callback. &nbsp;The callback should return 0 for success or &lt; 0 for an error. &nbsp;The </span><span class="c2 c3">ssl</span><span class="c2">&nbsp;and </span><span class="c2 c3">ctx</span><span class="c2">&nbsp;pointers are available for the users convenience. &nbsp;</span><span class="c2 c3">decOut</span><span class="c2">&nbsp;is the output buffer where the result of the decryption should be stored. &nbsp;</span><span class="c2 c3">decIn</span><span class="c2">&nbsp;is the encrypted input buffer and </span><span class="c2 c3">decInSz</span><span class="c2">&nbsp;notes the size of the buffer. &nbsp;</span><span class="c2 c3">content</span><span class="c2">&nbsp;and </span><span class="c2 c3">verify</span><span class="c2">&nbsp;are needed for wolfSSL_SetTlsHmacInner() and be passed along as is. &nbsp;</span><span class="c2 c3">padSz</span><span class="c2">&nbsp;is an output variable that should be set with the total value of the padding. &nbsp;That is, the mac size plus any padding and pad bytes. &nbsp;An example callback can be found wolfssl/test.h myDecryptVerifyCb().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">NA</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetMacEncryptCtx()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetMacEncryptCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.kab9yu324aqh"></a><span>wolfSSL_SetDecryptVerifyCtx</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_SetDecryptVerifyCtx(WOLFSSL*, void* ctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to set the Atomic User Record Processing Decrypt/Verify Callback Context to </span><span class="c2 c3">ctx</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">NA</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_SetDecryptVerifyCb()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetDecryptVerifyCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.qj10hrelxth5"></a><span>wolfSSL_GetDecryptVerifyCtx</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void* wolfSSL_GetDecryptVerifyCtx(WOLFSSL*);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to retrieve the Atomic User Record Processing Decrypt/Verify Callback Context previously stored with wolfSSL_SetDecryptVerifyCtx().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return a valid pointer to the context.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NULL</span><span class="c2">&nbsp;will be returned for a blank context.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_SetDecryptVerifyCb()</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetDecryptVerifyCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.uleop0yb23t"></a><span>wolfSSL_CTX_SetEccSignCb</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_CTX_SetEccSignCb(WOLFSSL_CTX*, CallbackEccSign);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">typedef int (*CallbackEccSign)(WOLFSSL* ssl,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;const unsigned char* in, unsigned int inSz,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;unsigned char* out, unsigned int* outSz,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;const unsigned char* keyDer, unsigned int keySz,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;void* ctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to set the Public Key Callback for ECC Signing. &nbsp;The callback should return 0 for success or &lt; 0 for an error. &nbsp;The </span><span class="c2 c3">ssl</span><span class="c2">&nbsp;and </span><span class="c2 c3">ctx</span><span class="c2">&nbsp;pointers are available for the users convenience. &nbsp;</span><span class="c2 c3">in</span><span class="c2">&nbsp;is the input buffer to sign while </span><span class="c2 c3">inSz</span><span class="c2">&nbsp;denotes the length of the input. &nbsp;</span><span class="c2 c3">out</span><span class="c2">&nbsp;is the output buffer where the result of the signature should be stored. &nbsp;</span><span class="c2 c3">outSz</span><span class="c2">&nbsp;is an input/output variable that specifies the size of the output buffer upon invocation and the actual size of the signature should be stored there before returning. &nbsp;</span><span class="c2 c3">keyDer</span><span class="c2">&nbsp;is the ECC Private key in ASN1 format and </span><span class="c2 c3">keySz</span><span class="c2">&nbsp;is the length of the key in bytes. &nbsp;An example callback can be found wolfssl/test.h myEccSign().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">NA</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetEccSignCtx()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetEccSignCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.kj6qelqqfkc9"></a><span>wolfSSL_SetEccSignCtx</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_SetEccSignCtx(WOLFSSL*, void* ctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to set the Public Key Ecc Signing Callback Context to </span><span class="c2 c3">ctx</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">NA</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_SetEccSignCb()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetEccSignCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.afq3o7wyrc02"></a><span>wolfSSL_GetEccSignCtx</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void* wolfSSL_GetEccSignCtx(WOLFSSL*);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to retrieve the Public Key Ecc Signing Callback Context previously stored with wolfSSL_SetEccSignCtx().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return a valid pointer to the context.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NULL</span><span class="c2">&nbsp;will be returned for a blank context.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_SetEccSignCb()</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetEccSignCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.9n9it3r9wufq"></a><span>wolfSSL_CTX_SetEccVerifyCb</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_CTX_SetEccVerifyCb(WOLFSSL_CTX*, CallbackEccVerify);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">typedef int (*CallbackEccVerify)(WOLFSSL* ssl,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;const unsigned char* sig, unsigned int sigSz,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;const unsigned char* hash, unsigned int hashSz,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;const unsigned char* keyDer, unsigned int keySz,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;int* result, void* ctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to set the Public Key Callback for ECC Verification. &nbsp;The callback should return 0 for success or &lt; 0 for an error. &nbsp;The </span><span class="c2 c3">ssl</span><span class="c2">&nbsp;and </span><span class="c2 c3">ctx</span><span class="c2">&nbsp;pointers are available for the users convenience. &nbsp;</span><span class="c2 c3">sig</span><span class="c2">&nbsp;is the signature to verify and </span><span class="c2 c3">sigSz</span><span class="c2">&nbsp;denotes the length of the signature. &nbsp;</span><span class="c2 c3">hash</span><span class="c2">&nbsp;is an input buffer containing the digest of the message and </span><span class="c2 c3">hashSz</span><span class="c2">&nbsp;denotes the length in bytes of the hash. &nbsp;</span><span class="c2 c3">result </span><span class="c2">is an output variable where the result of the verification should be stored, </span><span class="c2 c3">1</span><span class="c2">&nbsp;for success and </span><span class="c2 c3">0</span><span class="c2">&nbsp;for failure. &nbsp;</span><span class="c2 c3">keyDer</span><span class="c2">&nbsp;is the ECC Private key in ASN1 format and </span><span class="c2 c3">keySz</span><span class="c2">&nbsp;is the length of the key in bytes. &nbsp;An example callback can be found wolfssl/test.h myEccVerify().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">NA</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetEccVerifyCtx()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetEccVerifyCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.a0tvf0kui90u"></a><span>wolfSSL_SetEccVerifyCtx</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_SetEccVerifyCtx(WOLFSSL*, void* ctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to set the Public Key Ecc Verification Callback Context to </span><span class="c2 c3">ctx</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">NA</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_SetEccVerifyCb()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetEccVerifyCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.8c251silgx1l"></a><span>wolfSSL_GetEccVerifyCtx</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void* wolfSSL_GetEccVerifyCtx(WOLFSSL*);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to retrieve the Public Key Ecc Verification Callback Context previously stored with wolfSSL_SetEccVerifyCtx().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return a valid pointer to the context.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NULL</span><span class="c2">&nbsp;will be returned for a blank context.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_SetEccVerifyCb()</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetEccVerifyCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.isul27ek50lv"></a><span>wolfSSL_CTX_SetRsaSignCb</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_CTX_SetEccRsaCb(WOLFSSL_CTX*, CallbackRsaSign);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">typedef int (*CallbackRsaSign)(WOLFSSL* ssl,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;const unsigned char* in, unsigned int inSz,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;unsigned char* out, unsigned int* outSz,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;const unsigned char* keyDer, unsigned int keySz,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;void* ctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to set the Public Key Callback for RSA Signing. &nbsp;The callback should return 0 for success or &lt; 0 for an error. &nbsp;The </span><span class="c2 c3">ssl</span><span class="c2">&nbsp;and </span><span class="c2 c3">ctx</span><span class="c2">&nbsp;pointers are available for the users convenience. &nbsp;</span><span class="c2 c3">in</span><span class="c2">&nbsp;is the input buffer to sign while </span><span class="c2 c3">inSz</span><span class="c2">&nbsp;denotes the length of the input. &nbsp;</span><span class="c2 c3">out</span><span class="c2">&nbsp;is the output buffer where the result of the signature should be stored. &nbsp;</span><span class="c2 c3">outSz</span><span class="c2">&nbsp;is an input/output variable that specifies the size of the output buffer upon invocation and the actual size of the signature should be stored there before returning. &nbsp;</span><span class="c2 c3">keyDer</span><span class="c2">&nbsp;is the RSA Private key in ASN1 format and </span><span class="c2 c3">keySz</span><span class="c2">&nbsp;is the length of the key in bytes. &nbsp;An example callback can be found wolfssl/test.h myRsaSign().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">NA</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetRsaSignCtx()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetRsaSignCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.24bj78nkd2yq"></a><span>wolfSSL_SetRsaSignCtx</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_SetRsaSignCtx(WOLFSSL*, void* ctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to set the Public Key RSA Signing Callback Context to </span><span class="c2 c3">ctx</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">NA</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_SetRsaSignCb()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetRsaSignCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.x2o0c9nf3vxs"></a><span>wolfSSL_GetRsaSignCtx</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void* wolfSSL_GetRsaSignCtx(WOLFSSL*);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to retrieve the Public Key RSA Signing Callback Context previously stored with wolfSSL_SetRsaSignCtx().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return a valid pointer to the context.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NULL</span><span class="c2">&nbsp;will be returned for a blank context.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_SetRsaSignCb()</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetRsaSignCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.g2ci12fwqesm"></a><span>wolfSSL_CTX_SetRsaVerifyCb</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_CTX_SetRsaVerifyCb(WOLFSSL_CTX*, CallbackRsaVerify);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">typedef int (*CallbackRsaVerify)(WOLFSSL* ssl,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;unsigned char* sig, unsigned int sigSz,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;unsigned char** out,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;const unsigned char* keyDer, unsigned int keySz,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;void* ctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to set the Public Key Callback for RSA Verification. &nbsp;The callback should return the number of plaintext bytes for success or &lt; 0 for an error. &nbsp;The </span><span class="c2 c3">ssl</span><span class="c2">&nbsp;and </span><span class="c2 c3">ctx</span><span class="c2">&nbsp;pointers are available for the users convenience. &nbsp;</span><span class="c2 c3">sig</span><span class="c2">&nbsp;is the signature to verify and </span><span class="c2 c3">sigSz</span><span class="c2">&nbsp;denotes the length of the signature. &nbsp;</span><span class="c2 c3">out </span><span class="c2">should be set to the beginning of the verification buffer after the decryption process and any padding. &nbsp;</span><span class="c2 c3">keyDer</span><span class="c2">&nbsp;is the RSA Public key in ASN1 format and </span><span class="c2 c3">keySz</span><span class="c2">&nbsp;is the length of the key in bytes. &nbsp;An example callback can be found wolfssl/test.h myRsaVerify().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">NA</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetRsaVerifyCtx()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetRsaVerifyCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.1uvf06ucwj4r"></a><span>wolfSSL_SetRsaVerifyCtx</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_SetRsaVerifyCtx(WOLFSSL*, void* ctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to set the Public Key RSA Verification Callback Context to </span><span class="c2 c3">ctx</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">NA</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_SetRsaVerifyCb()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetRsaVerifyCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.scbjtzk6j5nv"></a><span>wolfSSL_GetRsaVerifyCtx</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void* wolfSSL_GetRsaVerifyCtx(WOLFSSL*);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to retrieve the Public Key RSA Verification Callback Context previously stored with wolfSSL_SetRsaVerifyCtx().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return a valid pointer to the context.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NULL</span><span class="c2">&nbsp;will be returned for a blank context.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_SetRsaVerifyCb()</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetRsaVerifyCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.p4c78i30vgpg"></a><span>wolfSSL_CTX_SetRsaEncCb</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_CTX_SetRsaEncCb(WOLFSSL_CTX*, CallbackRsaEnc);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">typedef int (*CallbackRsaEnc)(WOLFSSL* ssl,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;const unsigned char* in, unsigned int inSz,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;unsigned char* out, unsigned int* outSz,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;const unsigned char* keyDer, unsigned int keySz,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;void* ctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to set the Public Key Callback for RSA Public Encrypt. &nbsp;The callback should return 0 for success or &lt; 0 for an error. &nbsp;The </span><span class="c2 c3">ssl</span><span class="c2">&nbsp;and </span><span class="c2 c3">ctx</span><span class="c2">&nbsp;pointers are available for the users convenience. &nbsp;</span><span class="c2 c3">in</span><span class="c2">&nbsp;is the input buffer to encrypt while </span><span class="c2 c3">inSz</span><span class="c2">&nbsp;denotes the length of the input. &nbsp;</span><span class="c2 c3">out</span><span class="c2">&nbsp;is the output buffer where the result of the encryption should be stored. &nbsp;</span><span class="c2 c3">outSz</span><span class="c2">&nbsp;is an input/output variable that specifies the size of the output buffer upon invocation and the actual size of the encryption should be stored there before returning. &nbsp;</span><span class="c2 c3">keyDer</span><span class="c2">&nbsp;is the RSA Public key in ASN1 format and </span><span class="c2 c3">keySz</span><span class="c2">&nbsp;is the length of the key in bytes. &nbsp;An example callback can be found wolfssl/test.h myRsaEnc().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">NA</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetRsaEncCtx()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetRsaEncCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.hhex6xu1xx9j"></a><span>wolfSSL_SetRsaEncCtx</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_SetRsaEncCtx(WOLFSSL*, void* ctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to set the Public Key RSA Public Encrypt Callback Context to </span><span class="c2 c3">ctx</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">NA</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_SetRsaEncCb()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetRsaEncCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.p6d8r7jifxul"></a><span>wolfSSL_GetRsaEncCtx</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void* wolfSSL_GetRsaEncCtx(WOLFSSL*);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to retrieve the Public Key RSA Public Encrypt Callback Context previously stored with wolfSSL_SetRsaEncCtx().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return a valid pointer to the context.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NULL</span><span class="c2">&nbsp;will be returned for a blank context.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_SetRsaEncCb()</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetRsaEncCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.y6uu2op1horr"></a><span>wolfSSL_CTX_SetRsaDecCb</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_CTX_SetRsaDecCb(WOLFSSL_CTX*, CallbackRsaDec);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">typedef int (*CallbackRsaDec)(WOLFSSL* ssl,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;unsigned char* in, unsigned int inSz,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;unsigned char** out,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;const unsigned char* keyDer, unsigned int keySz,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp;void* ctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to set the Public Key Callback for RSA Private Decrypt. &nbsp;The callback should return the number of plaintext bytes for success or &lt; 0 for an error. &nbsp;The </span><span class="c2 c3">ssl</span><span class="c2">&nbsp;and </span><span class="c2 c3">ctx</span><span class="c2">&nbsp;pointers are available for the users convenience. &nbsp;</span><span class="c2 c3">in</span><span class="c2">&nbsp;is the input buffer to decrypt and </span><span class="c2 c3">inSz</span><span class="c2">&nbsp;denotes the length of the input. &nbsp;</span><span class="c2 c3">out </span><span class="c2">should be set to the beginning of the decryption buffer after the decryption process and any padding. &nbsp;</span><span class="c2 c3">keyDer</span><span class="c2">&nbsp;is the RSA Private key in ASN1 format and </span><span class="c2 c3">keySz</span><span class="c2">&nbsp;is the length of the key in bytes. &nbsp;An example callback can be found wolfssl/test.h myRsaDec().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">NA</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetRsaDecCtx()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetRsaDecCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.rgintb4xkx0x"></a><span>wolfSSL_SetRsaDecCtx</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_SetRsaDecCtx(WOLFSSL*, void* ctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to set the Public Key RSA Private Decrypt Callback Context to </span><span class="c2 c3">ctx</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">NA</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_SetRsaDecCb()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetRsaDecCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.fmbrko7brpja"></a><span>wolfSSL_GetRsaDecCtx</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void* wolfSSL_GetRsaDecCtx(WOLFSSL*);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to retrieve the Public Key RSA Private Decrypt Callback Context previously stored with wolfSSL_SetRsaDecCtx().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return a valid pointer to the context.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NULL</span><span class="c2">&nbsp;will be returned for a blank context.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_SetRsaDecCb()</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetRsaDecCtx()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h2 class="c4 c18"><a name="h.6j851mv9vu3k"></a><span>17.5 Error Handling and Debugging</span></h2>
    <hr>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The functions in this section have to do with printing and handling errors as well as enabling and disabling debugging in wolfSSL.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.5a07619wjhu1"></a><span>wolfSSL_ERR_error_string</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">char* wolfSSL_ERR_error_string(unsigned long errNumber, char* data);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function converts an error code returned by wolfSSL_get_error() into a more human-readable error string. &nbsp;</span><span class="c2 c3">errNumber</span><span class="c2">&nbsp;is the error code returned by wolfSSL_get_error() and </span><span class="c2 c3">data</span><span class="c2">&nbsp;is the storage buffer which the error string will be placed in.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The maximum length of </span><span class="c2 c3">data</span><span class="c2">&nbsp;is 80 characters by default, as defined by MAX_ERROR_SZ is wolfssl/wolfcrypt/error.h.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">On successful completion, this function returns the same string as is returned in </span><span class="c2 c3">data</span><span class="c2">. &nbsp;Upon failure, this function returns a string with the appropriate failure reason.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">errNumber</span><span class="c2">&nbsp;- error code returned by wolfSSL_get_error().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">data</span><span class="c2">&nbsp;- output buffer containing human-readable error string matching </span><span class="c2 c3">errNumber</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int err = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl;</span></p>
    <p class="c4"><span class="c0">char buffer[80];</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">err = wolfSSL_get_error(ssl, 0);</span></p>
    <p class="c4"><span class="c0">wolfSSL_ERR_error_string(err, buffer);</span></p>
    <p class="c4"><span class="c0">printf(&ldquo;err = %d, %s\n&rdquo;, err, buffer);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_error</span></p>
    <p class="c4"><span class="c2">wolfSSL_ERR_error_string_n</span></p>
    <p class="c4"><span class="c2">wolfSSL_ERR_print_errors_fp</span></p>
    <p class="c4"><span class="c2">wolfSSL_load_error_strings</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.kw9km0inzo2z"></a><span>wolfSSL_ERR_error_string_n</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_ERR_error_string_n(unsigned long e, char* buf, unsigned long len);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function is a version of wolfSSL_ERR_error_string() where </span><span class="c2 c3">len</span><span class="c2">&nbsp;specifies the maximum number of characters that may be written to </span><span class="c2 c3">buf</span><span class="c2">. &nbsp;Like wolfSSL_ERR_error_string(), this function converts an error code returned from wolfSSL_get_error() into a more human-readable error string. &nbsp;The human-readable string is placed in </span><span class="c2 c3">buf</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">This function has no return value.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">e</span><span class="c2">&nbsp;- error code returned by wolfSSL_get_error().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">buff</span><span class="c2">&nbsp;- output buffer containing human-readable error string matching </span><span class="c2 c3">e</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">len</span><span class="c2">&nbsp;- maximum length in characters which may be written to </span><span class="c2 c3">buf</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int err = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl;</span></p>
    <p class="c4"><span class="c0">char buffer[80];</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">err = wolfSSL_get_error(ssl, 0);</span></p>
    <p class="c4"><span class="c0">wolfSSL_ERR_error_string_n(err, buffer, 80);</span></p>
    <p class="c4"><span class="c0">printf(&ldquo;err = %d, %s\n&rdquo;, err, buffer);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_error</span></p>
    <p class="c4"><span class="c2">wolfSSL_ERR_error_string</span></p>
    <p class="c4"><span class="c2">wolfSSL_ERR_print_errors_fp</span></p>
    <p class="c4"><span class="c2">wolfSSL_load_error_strings</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.crdq814kk20k"></a><span>wolfSSL_ERR_print_errors_fp</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void &nbsp;wolfSSL_ERR_print_errors_fp(FILE* fp, int err);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function converts an error code returned by wolfSSL_get_error() into a more human-readable error string and prints that string to the output file - </span><span class="c2 c3">fp</span><span class="c2">. &nbsp;</span><span class="c2 c3">err</span><span class="c2">&nbsp;is the error code returned by wolfSSL_get_error() and </span><span class="c2 c3">fp</span><span class="c2">&nbsp;is the file which the error string will be placed in.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">This function has no return value.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">fp</span><span class="c2">&nbsp;- output file for human-readable error string to be written to.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">e</span><span class="c2">&nbsp;- error code returned by wolfSSL_get_error().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int err = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl;</span></p>
    <p class="c4"><span class="c0">FILE* fp = ...</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">err = wolfSSL_get_error(ssl, 0);</span></p>
    <p class="c4"><span class="c0">wolfSSL_ERR_print_errors_fp(fp, err);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_error</span></p>
    <p class="c4"><span class="c2">wolfSSL_ERR_error_string</span></p>
    <p class="c4"><span class="c2">wolfSSL_ERR_error_string_n</span></p>
    <p class="c4"><span class="c2">wolfSSL_load_error_strings</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.wzh6bf3rt4sj"></a><span>wolfSSL_get_error</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_get_error(WOLFSSL* ssl, int ret);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function returns a unique error code describing why the previous API function call (wolfSSL_connect, wolfSSL_accept, wolfSSL_read, wolfSSL_write, etc.) resulted in an error return code (SSL_FAILURE). &nbsp;The return value of the previous function is passed to wolfSSL_get_error through </span><span class="c2 c3">ret</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">After wolfSSL_get_error is called and returns the unique error code, wolfSSL_ERR_error_string() may be called to get a human-readable error string. &nbsp;See wolfSSL_ERR_error_string() for more information.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">On successful completion, this function will return the unique error code describing why the previous API function failed.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_ERROR_NONE</span><span class="c2">&nbsp;will be returned if </span><span class="c2 c3">ret</span><span class="c2">&nbsp;&gt; 0.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL object, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ret</span><span class="c2">&nbsp;- return value of the previous function that resulted in an error return code.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int err = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl;</span></p>
    <p class="c4"><span class="c0">char buffer[80];</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">err = wolfSSL_get_error(ssl, 0);</span></p>
    <p class="c4"><span class="c0">wolfSSL_ERR_error_string(err, buffer);</span></p>
    <p class="c4"><span class="c0">printf(&ldquo;err = %d, %s\n&rdquo;, err, buffer);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_ERR_error_string</span></p>
    <p class="c4"><span class="c2">wolfSSL_ERR_error_string_n</span></p>
    <p class="c4"><span class="c2">wolfSSL_ERR_print_errors_fp</span></p>
    <p class="c4"><span class="c2">wolfSSL_load_error_strings</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.3s04urt2ec9l"></a><span>wolfSSL_load_error_strings</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_load_error_strings(void);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function is for OpenSSL compatibility (SSL_load_error_string) only and takes no action.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">This function has no return value.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2">This function takes no parameters.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">wolfSSL_load_error_strings();</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_error</span></p>
    <p class="c4"><span class="c2">wolfSSL_ERR_error_string</span></p>
    <p class="c4"><span class="c2">wolfSSL_ERR_error_string_n</span></p>
    <p class="c4"><span class="c2">wolfSSL_ERR_print_errors_fp</span></p>
    <p class="c4"><span class="c2">wolfSSL_load_error_strings</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.hci5iomkyzr4"></a><span>wolfSSL_want_read</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_want_read(WOLFSSL* ssl)</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function is similar to calling wolfSSL_get_error() and getting SSL_ERROR_WANT_READ in return. &nbsp;If the underlying error state is SSL_ERROR_WANT_READ, this function will return 1, otherwise, 0.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">1</span><span class="c2">&nbsp;- wolfSSL_get_error() would return SSL_ERROR_WANT_READ, the underlying I/O has data available for reading.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">0</span><span class="c2">&nbsp;- There is no SSL_ERROR_WANT_READ error state.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_want_read(ssl);</span></p>
    <p class="c4"><span class="c0">if (ret == 1) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// underlying I/O has data available for reading (SSL_ERROR_WANT_READ)</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_want_write</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_error</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.efi0l46s3uin"></a><span>wolfSSL_want_write</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_want_write(WOLFSSL* ssl)</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function is similar to calling wolfSSL_get_error() and getting SSL_ERROR_WANT_WRITE in return. &nbsp;If the underlying error state is SSL_ERROR_WANT_WRITE, this function will return 1, otherwise, 0.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">1</span><span class="c2">&nbsp;- wolfSSL_get_error() would return SSL_ERROR_WANT_WRITE, the underlying I/O needs data to be written in order for progress to be made in the underlying SSL connection.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">0</span><span class="c2">&nbsp;- There is no SSL_ERROR_WANT_WRITE error state.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_want_write(ssl);</span></p>
    <p class="c4"><span class="c0">if (ret == 1) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// underlying I/O needs data to be written (SSL_ERROR_WANT_WRITE)</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_want_read</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_error</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.nm1lp4jwk2m1"></a><span>wolfSSL_Debugging_ON</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int &nbsp;wolfSSL_Debugging_ON(void);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">If logging has been enabled at build time this function turns on logging at runtime. &nbsp;To enable logging at build time use </span><span class="c2 c16">--enable-debug</span><span class="c2">&nbsp;or define </span><span class="c2 c3">DEBUG_WOLFSSL</span></p>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful this function will return 0.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NOT_COMPILED_IN</span><span class="c2">&nbsp;is the error that will be returned if logging isn&rsquo;t enabled for this build.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2">This function has no parameters.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">wolfSSL_Debugging_ON();</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_Debugging_OFF</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetLoggingCb</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.zanp9ofni59i"></a><span>wolfSSL_Debugging_OFF</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void &nbsp;wolfSSL_Debugging_OFF(void);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function turns off runtime logging messages. &nbsp;If they&rsquo;re already off, no action is taken.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">No return values are returned by this function.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2">This function has no parameters.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">wolfSSL_Debugging_OFF();</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_Debugging_ON</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetLoggingCb</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h2 class="c4 c18"><a name="h.ww63bm3ufrna"></a><span>17.6 OCSP and CRL</span></h2>
    <hr>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The functions in this section have to do with using OCSP (Online Certificate Status Protocol) and CRL (Certificate Revocation List) with wolfSSL.</span></p>
    <h3 class="c7 c4"><a name="h.so07j5m3s3wz"></a><span>wolfSSL_CTX_EnableOCSP</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">long wolfSSL_CTX_EnableOCSP(WOLFSSL_CTX* ctx, int options);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function sets options to configure behavior of OCSP functionality in wolfSSL. &nbsp;The value of </span><span class="c2 c3">options</span><span class="c2">&nbsp;if formed by or&rsquo;ing one or more of the following options:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WOLFSSL_OCSP_ENABLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
    <p class="c14 c4"><span class="c2">- enable OCSP lookups</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WOLFSSL_OCSP_URL_OVERRIDE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
    <p class="c4 c14"><span class="c2">- use the override URL instead of the URL in certificates.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The override URL is specified using the wolfSSL_CTX_SetOCSP_OverrideURL() function.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">This function only sets the OCSP options when wolfSSL has been compiled with OCSP support (--enable-ocsp, #define HAVE_OCSP).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_SUCCESS</span><span class="c2">&nbsp;is returned upon success</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FAILURE</span><span class="c2">&nbsp;is returned upon failure</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NOT_COMPILED_IN </span><span class="c2">is returned when this function has been called, but OCSP support was not enabled when wolfSSL was compiled.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx </span><span class="c2">- pointer to the SSL context, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">options</span><span class="c2">&nbsp;- value used to set the OCSP options.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">wolfSSL_CTX_OCSP_set_options(ctx, WOLFSSL_OCSP_ENABLE);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_OCSP_set_override_url</span></p>
    <p class="c4 c5 c19"><span class="c2 c3"></span></p>
    <p class="c4 c5 c19"><span class="c2 c3"></span></p>
    <h3 class="c7 c4"><a name="h.27gsoc9k6wgs"></a><span>wolfSSL_CTX_SetOCSP_OverrideURL</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">int &nbsp;wolfSSL_CTX_SetOCSP_OverrideURL(WOLFSSL_CTX* ctx, const char* url);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function manually sets the URL for OCSP to use. &nbsp;By default, OCSP will use the URL found in the individual certificate unless the WOLFSSL_OCSP_URL_OVERRIDE option is set using the wolfSSL_CTX_EnableOCSP.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_SUCCESS</span><span class="c2">&nbsp;is returned upon success</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FAILURE</span><span class="c2">&nbsp;is returned upon failure</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NOT_COMPILED_IN </span><span class="c2">is returned when this function has been called, but OCSP support was not enabled when wolfSSL was compiled.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx </span><span class="c2">- pointer to the SSL context, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">url</span><span class="c2">&nbsp;- pointer to the OCSP URL for wolfSSL to use.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">wolfSSL_CTX_OCSP_set_override_url(ctx, &ldquo;custom-url-here&rdquo;);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_OCSP_set_options</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h2 class="c4 c18"><a name="h.yvnq22vyrc8k"></a><span>17.7 Informational</span></h2>
    <hr>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The functions in this section are informational. &nbsp;They allow the application to gather some kind of information about the current status or setup of wolfSSL.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.z3cqacb0yj1i"></a><span>wolfSSL_GetObjectSize</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_GetObjectSize(void);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function returns the size of the WOLFSSL object and will be dependent on build options and settings. &nbsp;If SHOW_SIZES has been defined when building wolfSSL, this function will also print the sizes of individual objects within the WOLFSSL object (Suites, Ciphers, etc.) to stdout.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">This function returns the size of the WOLFSSL object.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2">This function has no parameters.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int size = 0;</span></p>
    <p class="c4"><span class="c0">size = wolfSSL_GetObjectSize();</span></p>
    <p class="c4"><span class="c0">printf(&ldquo;sizeof(WOLFSSL) = %d\n&rdquo;, size);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_new();</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.ehsfg7yklg9f"></a><span>wolfSSL_GetMacSecret</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">const unsigned char* wolfSSL_GetMacSecret(WOLFSSL* ssl, int verify);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows retrieval of the Hmac/Mac secret from the handshake process. &nbsp;The </span><span class="c2 c3">verify</span><span class="c2">&nbsp;parameter specifies whether this is for verification of a peer message.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return a valid pointer to the secret. &nbsp;The size of the secret can be obtained from wolfSSL_GetHmacSize().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NULL</span><span class="c2">&nbsp;will be returned for an error state.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL object, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">verify</span><span class="c2">&nbsp;- specifies whether this is for verification of a peer message.</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetHmacSize()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.2kpsgqplu4oh"></a><span>wolfSSL_GetClientWriteKey</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">const unsigned char* wolfSSL_GetClientWriteKey(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows retrieval of the client write key from the handshake process.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return a valid pointer to the key. &nbsp;The size of the key can be obtained from wolfSSL_GetKeySize().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NULL</span><span class="c2">&nbsp;will be returned for an error state.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL object, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetKeySize()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetClientWriteIV()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.kciowt7xuq6b"></a><span>wolfSSL_GetClientWriteIV</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">const unsigned char* wolfSSL_GetClientWriteIV(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows retrieval of the client write IV (initialization vector) from the handshake process.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return a valid pointer to the IV. &nbsp;The size of the IV can be obtained from wolfSSL_GetCipherBlockSize().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NULL</span><span class="c2">&nbsp;will be returned for an error state.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL object, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetCipherBlockSize()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetClientWriteKey()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.et2fxlw2ig6h"></a><span>wolfSSL_GetServerWriteKey</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">const unsigned char* wolfSSL_GetServerWriteKey(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows retrieval of the server write key from the handshake process.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return a valid pointer to the key. &nbsp;The size of the key can be obtained from wolfSSL_GetKeySize().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NULL</span><span class="c2">&nbsp;will be returned for an error state.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL object, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetKeySize()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetServerWriteIV()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.9j87rsy3yit9"></a><span>wolfSSL_GetServerWriteIV</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">const unsigned char* wolfSSL_GetServerWriteIV(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows retrieval of the server write IV (initialization vector) from the handshake process.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return a valid pointer to the IV. &nbsp;The size of the IV can be obtained from wolfSSL_GetCipherBlockSize().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NULL</span><span class="c2">&nbsp;will be returned for an error state.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL object, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetCipherBlockSize()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetClientWriteKey()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.exspgz8oh3zr"></a><span>wolfSSL_GetKeySize</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_GetKeySize(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows retrieval of the key size from the handshake process.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return the key size in bytes.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;will be returned for an error state.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL object, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetClientWriteKey()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetServerWriteKey()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.2s3zjmv15zb"></a><span>wolfSSL_GetSide</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_GetSide(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows retrieval of the side of this WOLFSSL connection.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return either </span><span class="c2 c3">WOLFSSL_SERVER_END</span><span class="c2">&nbsp;or </span><span class="c2 c3">WOLFSSL_CLIENT_END</span><span class="c2">&nbsp;depending on the side of WOLFSSL object.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;will be returned for an error state.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL object, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetClientWriteKey()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetServerWriteKey()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.i1htj2r7p7yw"></a><span>wolfSSL_IsTLSv1_1</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_IsTLSV1_1(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to determine if the negotiated protocol version is at least TLS version 1.1 or greater.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">1</span><span class="c2">&nbsp;for true or </span><span class="c2 c3">0</span><span class="c2">&nbsp;for false.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;will be returned for an error state.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL object, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetSide()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.3tok1mcvw0bf"></a><span>wolfSSL_GetBulkCipher</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_GetBulkCipher(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to determine the negotiated bulk cipher algorithm from the handshake. </span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return one of the following:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">wolfssl_cipher_null</span></p>
    <p class="c4"><span class="c2">wolfssl_des</span></p>
    <p class="c4"><span class="c2">wolfssl_triple_des</span></p>
    <p class="c4"><span class="c2">wolfssl_aes</span></p>
    <p class="c4"><span class="c2">wolfssl_aes_gcm</span></p>
    <p class="c4"><span class="c2">wolfssl_aes_ccm</span></p>
    <p class="c4"><span class="c2">wolfssl_camellia</span></p>
    <p class="c4"><span class="c2">wolfssl_hc128</span></p>
    <p class="c4"><span class="c2">wolfssl_rabbit</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;will be returned for an error state.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL object, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetCipherBlockSize()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetKeySize()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c19"><span class="c2 c3">wolfSSL_GetCipherBlockSize</span></p>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_GetCipherBlockSize(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to determine the negotiated cipher block size from the handshake.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return the size in bytes of the cipher block size.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;will be returned for an error state.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL object, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetBulkCipher()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetKeySize()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.29gkgi3qjqix"></a><span>wolfSSL_GetAeadMacSize</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_GetAeadMacSize(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to determine the negotiated aead mac size from the handshake. &nbsp;For cipher type </span><span class="c2 c3">WOLFSSL_AEAD_TYPE</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return the size in bytes of the aead mac size.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;will be returned for an error state.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL object, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetBulkCipher()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetKeySize()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.taxx0427c21j"></a><span>wolfSSL_GetHmacSize</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_GetHmacSize(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to determine the negotiated (h)mac size from the handshake. &nbsp;For cipher types except </span><span class="c2 c3">WOLFSSL_AEAD_TYPE</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return the size in bytes of the (h)mac size.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;will be returned for an error state.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL object, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetBulkCipher()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetHmacType()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.cboy486vx3dl"></a><span>wolfSSL_GetHmacType</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_GetHmacType(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to determine the negotiated (h)mac type from the handshake. &nbsp;For cipher types except </span><span class="c2 c3">WOLFSSL_AEAD_TYPE</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return one of the following:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">MD5</span></p>
    <p class="c4"><span class="c2">SHA</span></p>
    <p class="c4"><span class="c2">SHA256</span></p>
    <p class="c4"><span class="c2">SHA384</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG </span><span class="c2">or</span><span class="c2 c3">&nbsp;SSL_FATAL_ERROR</span><span class="c2">&nbsp;will be returned for an error state.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL object, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetBulkCipher()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetHmacSize()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.16ad53l0ww5"></a><span>wolfSSL_GetCipherType</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_GetCipherType(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allows caller to determine the negotiated cipher type from the handshake.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return one of the following:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">WOLFSSL_BLOCK_TYPE</span></p>
    <p class="c4"><span class="c2">WOLFSSL_STREAM_TYPE</span></p>
    <p class="c4"><span class="c2">WOLFSSL_AEAD_TYPE</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;will be returned for an error state.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL object, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetBulkCipher()</span></p>
    <p class="c4"><span class="c2">wolfSSL_GetHmacType()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h2 class="c4 c18"><a name="h.h34d25wzbdsf"></a><span>17.8 Connection, Session, and I/O</span></h2>
    <hr>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The functions in this section deal with setting up the SSL/TLS connection, managing SSL sessions, and input/output.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.515wx179txqg"></a><span>wolfSSL_accept</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int &nbsp;wolfSSL_accept(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function is called on the server side and waits for an SSL client to initiate the SSL/TLS handshake. &nbsp;When this function is called, the underlying communication channel has already been set up.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">wolfSSL_accept() works with both blocking and non-blocking I/O. &nbsp;When the underlying I/O is non-blocking, wolfSSL_accept() will return when the underlying I/O could not satisfy the needs of of wolfSSL_accept to continue the handshake. &nbsp;In this case, a call to wolfSSL_get_error() will yield either </span><span class="c2 c3">SSL_ERROR_WANT_READ</span><span class="c2">&nbsp;or </span><span class="c2 c3">SSL_ERROR_WANT_WRITE</span><span class="c2">. &nbsp;The calling process must then repeat the call to wolfSSL_accept when data is available to read and wolfSSL will pick up where it left off. When using a non-blocking socket, nothing needs to be done, but select() can be used to check for the required condition.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If the underlying I/O is blocking, wolfSSL_accept() will only return once the handshake has been finished or an error occurred.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FATAL_ERROR</span><span class="c2">&nbsp;will be returned if an error occurred. &nbsp;To get a more detailed error code, call wolfSSL_get_error().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL structure, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">int err = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl;</span></p>
    <p class="c4"><span class="c0">char buffer[80];</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_accept(ssl);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c15 c4"><span class="c0">err = wolfSSL_get_error(ssl, ret);</span></p>
    <p class="c15 c4"><span class="c0">printf(&ldquo;error = %d, %s\n&rdquo;, err, wolfSSL_ERR_error_string(err, buffer));<br>}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_error</span></p>
    <p class="c4"><span class="c2">wolfSSL_connect</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.1reog6pqmuiu"></a><span>wolfSSL_connect</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int &nbsp;wolfSSL_connect(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function is called on the client side and initiates an SSL/TLS handshake with a server. &nbsp;When this function is called, the underlying communication channel has already been set up.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">wolfSSL_connect() works with both blocking and non-blocking I/O. &nbsp;When the underlying I/O is non-blocking, wolfSSL_connect() will return when the underlying I/O could not satisfy the needs of of wolfSSL_connect to continue the handshake. &nbsp;In this case, a call to wolfSSL_get_error() will yield either </span><span class="c2 c3">SSL_ERROR_WANT_READ</span><span class="c2">&nbsp;or </span><span class="c2 c3">SSL_ERROR_WANT_WRITE</span><span class="c2">. &nbsp;The calling process must then repeat the call to wolfSSL_connect() when the underlying I/O is ready and wolfSSL will pick up where it left off. When using a non-blocking socket, nothing needs to be done, but select() can be used to check for the required condition.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If the underlying I/O is blocking, wolfSSL_connect() will only return once the handshake has been finished or an error occurred.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">wolfSSL takes a different approach to certificate verification than OpenSSL does. &nbsp;The default policy for the client is to verify the server, this means that if you don&#39;t load CAs to verify the server you&#39;ll get a connect error, unable to verify (-155). &nbsp;It you want to mimic OpenSSL behavior of having SSL_connect succeed even if verifying the server fails and reducing security you can do this by calling:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, 0);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">before calling SSL_new(); &nbsp;Though it&#39;s not recommended.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FATAL_ERROR</span><span class="c2">&nbsp;will be returned if an error occurred. &nbsp;To get a more detailed error code, call wolfSSL_get_error().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL structure, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">int err = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl;</span></p>
    <p class="c4"><span class="c0">char buffer[80];</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_connect(ssl);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c15 c4"><span class="c0">err = wolfSSL_get_error(ssl, ret);</span></p>
    <p class="c15 c4"><span class="c0">printf(&ldquo;error = %d, %s\n&rdquo;, err, wolfSSL_ERR_error_string(err, buffer));<br>}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_error</span></p>
    <p class="c4"><span class="c2">wolfSSL_accept</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.sqp4gpyz6uqe"></a><span>wolfSSL_connect_cert</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_connect_cert(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function is called on the client side and initiates an SSL/TLS handshake with a server only long enough to get the peer&rsquo;s certificate chain. &nbsp;When this function is called, the underlying communication channel has already been set up.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">wolfSSL_connect_cert() works with both blocking and non-blocking I/O. &nbsp;When the underlying I/O is non-blocking, wolfSSL_connect_cert() will return when the underlying I/O could not satisfy the needs of of wolfSSL_connect_cert() to continue the handshake. &nbsp;In this case, a call to wolfSSL_get_error() will yield either </span><span class="c2 c3">SSL_ERROR_WANT_READ</span><span class="c2">&nbsp;or </span><span class="c2 c3">SSL_ERROR_WANT_WRITE</span><span class="c2">. &nbsp;The calling process must then repeat the call to wolfSSL_connect_cert() when the underlying I/O is ready and wolfSSL will pick up where it left off. When using a non-blocking socket, nothing needs to be done, but select() can be used to check for the required condition.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If the underlying I/O is blocking, wolfSSL_connect_cert() will only return once the peer&rsquo;s certificate chain has been received.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FAILURE</span><span class="c2">&nbsp;will be returned if the SSL session parameter is NULL.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FATAL_ERROR</span><span class="c2">&nbsp;will be returned if an error occurred. &nbsp;To get a more detailed error code, call wolfSSL_get_error().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL structure, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">int err = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl;</span></p>
    <p class="c4"><span class="c0">char buffer[80];</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_connect_cert(ssl);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c15 c4"><span class="c0">err = wolfSSL_get_error(ssl, ret);</span></p>
    <p class="c4 c15"><span class="c0">printf(&ldquo;error = %d, %s\n&rdquo;, err, wolfSSL_ERR_error_string(err, buffer));<br>}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_error</span></p>
    <p class="c4"><span class="c2">wolfSSL_connect</span></p>
    <p class="c4"><span class="c2">wolfSSL_accept</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.7fi34sxsklbe"></a><span>wolfSSL_get_fd</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_get_fd(const WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function returns the file descriptor (</span><span class="c2 c3">fd</span><span class="c2">) used as the input/output facility for the SSL connection. &nbsp;Typically this will be a socket file descriptor.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return the SSL session file descriptor.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int sockfd;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">sockfd = wolfSSL_get_fd(ssl);</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_set_fd</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.btz8zz7mwpnj"></a><span>wolfSSL_get_session</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">WOLFSSL_SESSION* wolfSSL_get_session(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function returns a pointer to the current session (WOLFSSL_SESSION) used in </span><span class="c2 c3">ssl</span><span class="c2">. &nbsp;The WOLFSSL_SESSION pointed to contains all the necessary information required to perform a session resumption and reestablish the connection without a new handshake.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">For session resumption, before calling wolfSSL_shutdown() with your session object, an application should save the session ID from the object with a call to wolfSSL_get_session(), which returns a pointer to the session. &nbsp;Later, the application should create a new WOLFSSL object and assign the saved session with wolfSSL_set_session(). &nbsp;At this point, the application may call wolfSSL_connect() and wolfSSL will try to resume the session. &nbsp;The wolfSSL server code allows session resumption by default.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return a pointer to the the current SSL session object.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NULL</span><span class="c2">&nbsp;will be returned if </span><span class="c2 c3">ssl</span><span class="c2">&nbsp;is NULL, the SSL session cache is disabled, wolfSSL doesn&rsquo;t have the Session ID available, or mutex functions fail.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_SESSION* session = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">session = wolfSSL_get_session(ssl);</span></p>
    <p class="c4"><span class="c0">if (session == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// failed to get session pointer</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_set_session</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.f3qesxecprw9"></a><span>wolfSSL_get_using_nonblock</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_get_using_nonblock(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function allows the application to determine if wolfSSL is using non-blocking I/O. &nbsp;If wolfSSL is using non-blocking I/O, this function will return 1, otherwise 0.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">After an application creates a WOLFSSL object, if it will be used with a non-blocking socket, call wolfSSL_set_using_nonblock() on it. This lets the WOLFSSL object know that receiving EWOULDBLOCK means that the recvfrom call would block rather than that it timed out.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">0</span><span class="c2">&nbsp;- underlying I/O is blocking.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">1</span><span class="c2">&nbsp;- underlying I/O is non-blocking</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_get_using_nonblock(ssl);</span></p>
    <p class="c4"><span class="c0">if (ret == 1) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// underlying I/O is non-blocking</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_set_session</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.2bbx5ivhiutz"></a><span>wolfSSL_flush_sessions</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_flush_sessions(WOLFSSL_CTX *ctx, long tm);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function flushes session from the session cache which have expired. &nbsp;The time, </span><span class="c2 c3">tm</span><span class="c2">, is used for the time comparison.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">Note that wolfSSL currently uses a static table for sessions, so no flushing is needed. &nbsp;As such, this function is currently just a stub. &nbsp;This function provides OpenSSL compatibility (SSL_flush_sessions) when wolfSSL is compiled with the OpenSSL compatibility layer.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">This function does not have a return value.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx</span><span class="c2">&nbsp;- a pointer to a WOLFSSL_CTX structure, created using wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">tm</span><span class="c2">&nbsp;- time used in session expiration comparison.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ssl;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">wolfSSL_flush_sessions(ctx, time(0));</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_session</span></p>
    <p class="c4"><span class="c2">wolfSSL_set_session</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.q6pic56059ps"></a><span>wolfSSL_negotiate</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_negotiate(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Performs the actual connect or accept based on the side of the SSL method. &nbsp;If called from the client side then an </span><span class="c2 c16">wolfSSL_connect() </span><span class="c2">is done while a </span><span class="c2 c16">wolfSSL_accept()</span><span class="c2">&nbsp;is performed if called from the server side.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2 c3">SSL_SUCCESS</span><span class="c2">&nbsp;will be returned if successful. (Note, older versions will return 0.)</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FATAL_ERROR</span><span class="c2">&nbsp;will be returned if the underlying call resulted in an error. Use wolfSSL_get_error() to get a specific error code.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4"><span class="c0">int ret = SSL_FATAL_ERROR;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_negotiate(ssl);</span></p>
    <p class="c4"><span class="c0">if (ret == SSL_FATAL_ERROR) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// SSL establishment failed</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int error_code = wolfSSL_get_error(ssl);</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">SSL_connect</span></p>
    <p class="c4"><span class="c2">SSL_accept</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.m2mwkzu9m49g"></a><span>wolfSSL_peek</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_peek(WOLFSSL* ssl, void* data, int sz);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function copies </span><span class="c2 c3">sz</span><span class="c2">&nbsp;bytes from the SSL session (</span><span class="c2 c3">ssl</span><span class="c2">) internal read buffer into the buffer </span><span class="c2 c3">data</span><span class="c2">. &nbsp;This function is identical to wolfSSL_read() except that the data in the internal SSL session receive buffer is not removed or modified.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If necessary, like wolfSSL_read(), wolfSSL_peek() will negotiate an SSL/TLS session if the handshake has not already been performed yet by wolfSSL_connect() or wolfSSL_accept().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The SSL/TLS protocol uses SSL records which have a maximum size of 16kB (the max record size can be controlled by the MAX_RECORD_SIZE define in &lt;wolfssl_root&gt;/wolfssl/internal.h). &nbsp;As such, wolfSSL needs to read an entire SSL record internally before it is able to process and decrypt the record. &nbsp;Because of this, a call to wolfSSL_peek() will only be able to return the maximum buffer size which has been decrypted at the time of calling. &nbsp;There may be additional not-yet-decrypted data waiting in the internal wolfSSL receive buffer which will be retrieved and decrypted with the next call to wolfSSL_peek() / wolfSSL_read().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If </span><span class="c2 c3">sz</span><span class="c2">&nbsp;is larger than the number of bytes in the internal read buffer, SSL_peek() will return the bytes available in the internal read buffer. &nbsp;If no bytes are buffered in the internal read buffer yet, a call to wolfSSL_peek() will trigger processing of the next record.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">&gt;0</span><span class="c2">&nbsp;- the number of bytes read upon success.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">0</span><span class="c2">&nbsp;- will be returned upon failure. &nbsp;This may be caused by a either a clean (close notify alert) shutdown or just that the peer closed the connection. &nbsp;Call wolfSSL_get_error() for the specific error code.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FATAL_ERROR</span><span class="c2">&nbsp;- will be returned upon failure when either an error occurred or, when using non-blocking sockets, the SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE error was received and and the application needs to call wolfSSL_peek() again. &nbsp;Use wolfSSL_get_error() to get a specific error code.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">data</span><span class="c2">&nbsp;- buffer where wolfSSL_peek() will place data read.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">sz</span><span class="c2">&nbsp;- number of bytes to read into </span><span class="c2 c3">data</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">char reply[1024];</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">input = wolfSSL_peek(ssl, reply, sizeof(reply));</span></p>
    <p class="c4"><span class="c0">if (input &gt; 0) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// &ldquo;input&rdquo; number of bytes returned into buffer &ldquo;reply&rdquo;</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_read</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.zhveeqr1ci4m"></a><span>wolfSSL_pending</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_pending(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function returns the number of bytes which are buffered and available in the SSL object to be read by wolfSSL_read().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2">This function returns the number of bytes pending.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int pending = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">pending = wolfSSL_pending(ssl);</span></p>
    <p class="c4"><span class="c0">printf(&ldquo;There are %d bytes buffered and available for reading&rdquo;, pending);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_recv</span></p>
    <p class="c4"><span class="c2">wolfSSL_read</span></p>
    <p class="c4"><span class="c2">wolfSSL_peek</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.npw5ndkw3vnv"></a><span>wolfSSL_read</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_read(WOLFSSL* ssl, void* data, int sz);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function reads </span><span class="c2 c3">sz</span><span class="c2">&nbsp;bytes from the SSL session (</span><span class="c2 c3">ssl</span><span class="c2">) internal read buffer into the buffer </span><span class="c2 c3">data</span><span class="c2">. &nbsp;The bytes read are removed from the internal receive buffer.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If necessary wolfSSL_read() will negotiate an SSL/TLS session if the handshake has not already been performed yet by wolfSSL_connect() or wolfSSL_accept().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The SSL/TLS protocol uses SSL records which have a maximum size of 16kB (the max record size can be controlled by the MAX_RECORD_SIZE define in &lt;wolfssl_root&gt;/wolfssl/internal.h). &nbsp;As such, wolfSSL needs to read an entire SSL record internally before it is able to process and decrypt the record. &nbsp;Because of this, a call to wolfSSL_read() will only be able to return the maximum buffer size which has been decrypted at the time of calling. &nbsp;There may be additional not-yet-decrypted data waiting in the internal wolfSSL receive buffer which will be retrieved and decrypted with the next call to wolfSSL_read().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If </span><span class="c2 c3">sz</span><span class="c2">&nbsp;is larger than the number of bytes in the internal read buffer, SSL_read() will return the bytes available in the internal read buffer. &nbsp;If no bytes are buffered in the internal read buffer yet, a call to wolfSSL_read() will trigger processing of the next record.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">&gt;0</span><span class="c2">&nbsp;- the number of bytes read upon success.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">0</span><span class="c2">&nbsp;- will be returned upon failure. &nbsp;This may be caused by a either a clean (close notify alert) shutdown or just that the peer closed the connection. &nbsp;Call wolfSSL_get_error() for the specific error code.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FATAL_ERROR</span><span class="c2">&nbsp;- will be returned upon failure when either an error occurred or, when using non-blocking sockets, the SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE error was received and and the application needs to call wolfSSL_read() again. &nbsp;Use wolfSSL_get_error() to get a specific error code.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">data</span><span class="c2">&nbsp;- buffer where wolfSSL_read() will place data read.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">sz</span><span class="c2">&nbsp;- number of bytes to read into </span><span class="c2 c3">data</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">char reply[1024];</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">input = wolfSSL_read(ssl, reply, sizeof(reply));</span></p>
    <p class="c4"><span class="c0">if (input &gt; 0) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// &ldquo;input&rdquo; number of bytes returned into buffer &ldquo;reply&rdquo;</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c2">See wolfSSL examples (client, server, echoclient, echoserver) for more complete examples of wolfSSL_read().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_recv</span></p>
    <p class="c4"><span class="c2">wolfSSL_write</span></p>
    <p class="c4"><span class="c2">wolfSSL_peek</span></p>
    <p class="c4"><span class="c2">wolfSSL_pending</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.mh7at6s3pdhj"></a><span>wolfSSL_recv</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_recv(WOLFSSL* ssl, void* data, int sz, int flags);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function reads </span><span class="c2 c3">sz</span><span class="c2">&nbsp;bytes from the SSL session (</span><span class="c2 c3">ssl</span><span class="c2">) internal read buffer into the buffer </span><span class="c2 c3">data</span><span class="c2">&nbsp;using the specified </span><span class="c2 c3">flags</span><span class="c2">&nbsp;for the underlying recv operation. &nbsp;The bytes read are removed from the internal receive buffer. &nbsp;This function is identical to wolfSSL_read() except that it allows the application to set the recv flags for the underlying read operation.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If necessary wolfSSL_recv() will negotiate an SSL/TLS session if the handshake has not already been performed yet by wolfSSL_connect() or wolfSSL_accept().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The SSL/TLS protocol uses SSL records which have a maximum size of 16kB (the max record size can be controlled by the MAX_RECORD_SIZE define in &lt;wolfssl_root&gt;/wolfssl/internal.h). &nbsp;As such, wolfSSL needs to read an entire SSL record internally before it is able to process and decrypt the record. &nbsp;Because of this, a call to wolfSSL_recv() will only be able to return the maximum buffer size which has been decrypted at the time of calling. &nbsp;There may be additional not-yet-decrypted data waiting in the internal wolfSSL receive buffer which will be retrieved and decrypted with the next call to wolfSSL_recv().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If </span><span class="c2 c3">sz</span><span class="c2">&nbsp;is larger than the number of bytes in the internal read buffer, SSL_recv() will return the bytes available in the internal read buffer. &nbsp;If no bytes are buffered in the internal read buffer yet, a call to wolfSSL_recv() will trigger processing of the next record.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">&gt;0</span><span class="c2">&nbsp;- the number of bytes read upon success.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">0</span><span class="c2">&nbsp;- will be returned upon failure. &nbsp;This may be caused by a either a clean (close notify alert) shutdown or just that the peer closed the connection. &nbsp;Call wolfSSL_get_error() for the specific error code.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FATAL_ERROR</span><span class="c2">&nbsp;- will be returned upon failure when either an error occurred or, when using non-blocking sockets, the SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE error was received and and the application needs to call wolfSSL_recv() again. &nbsp;Use wolfSSL_get_error() to get a specific error code.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">data</span><span class="c2">&nbsp;- buffer where wolfSSL_recv() will place data read.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">sz</span><span class="c2">&nbsp;- number of bytes to read into </span><span class="c2 c3">data</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">flags</span><span class="c2">&nbsp;- the recv flags to use for the underlying recv operation.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">char reply[1024];</span></p>
    <p class="c4"><span class="c0">int flags = ... ;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">input = wolfSSL_recv(ssl, reply, sizeof(reply), flags);</span></p>
    <p class="c4"><span class="c0">if (input &gt; 0) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// &ldquo;input&rdquo; number of bytes returned into buffer &ldquo;reply&rdquo;</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_read</span></p>
    <p class="c4"><span class="c2">wolfSSL_write</span></p>
    <p class="c4"><span class="c2">wolfSSL_peek</span></p>
    <p class="c4"><span class="c2">wolfSSL_pending</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.dxj1t3penvmb"></a><span>wolfSSL_send</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_send(WOLFSSL* ssl, const void* data, int sz, int flags);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function writes </span><span class="c2 c3">sz</span><span class="c2">&nbsp;bytes from the buffer, </span><span class="c2 c3">data</span><span class="c2">, to the SSL connection, </span><span class="c2 c3">ssl</span><span class="c2">, using the specified </span><span class="c2 c3">flags</span><span class="c2">&nbsp;for the underlying write operation.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If necessary wolfSSL_send() will negotiate an SSL/TLS session if the handshake has not already been performed yet by wolfSSL_connect() or wolfSSL_accept().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">wolfSSL_send() works with both blocking and non-blocking I/O. &nbsp;When the underlying I/O is non-blocking, wolfSSL_send() will return when the underlying I/O could not satisfy the needs of of wolfSSL_send to continue. &nbsp;In this case, a call to wolfSSL_get_error() will yield either </span><span class="c2 c3">SSL_ERROR_WANT_READ</span><span class="c2">&nbsp;or </span><span class="c2 c3">SSL_ERROR_WANT_WRITE</span><span class="c2">. &nbsp;The calling process must then repeat the call to wolfSSL_send() when the underlying I/O is ready.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If the underlying I/O is blocking, wolfSSL_send() will only return once the buffer </span><span class="c2 c3">data</span><span class="c2">&nbsp;of size </span><span class="c2 c3">sz</span><span class="c2">&nbsp;has been completely written or an error occurred.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">&gt;0</span><span class="c2">&nbsp;- the number of bytes written upon success.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">0</span><span class="c2">&nbsp;- will be returned upon failure. &nbsp;Call wolfSSL_get_error() for the specific error code.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FATAL_ERROR</span><span class="c2">&nbsp;- will be returned upon failure when either an error occurred or, when using non-blocking sockets, the SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE error was received and and the application needs to call wolfSSL_send() again. &nbsp;Use wolfSSL_get_error() to get a specific error code.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">data</span><span class="c2">&nbsp;- data buffer to send to peer.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">sz</span><span class="c2">&nbsp;- size, in bytes, of </span><span class="c2 c3">data</span><span class="c2">&nbsp;to be sent to peer.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">flags</span><span class="c2">&nbsp;- the send flags to use for the underlying send operation.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">char msg[64] = &ldquo;hello wolfssl!&rdquo;;</span></p>
    <p class="c4"><span class="c0">int msgSz = (int)strlen(msg);</span></p>
    <p class="c4"><span class="c0">int flags = ... ;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">input = wolfSSL_send(ssl, msg, msgSz, flags);</span></p>
    <p class="c4"><span class="c0">if (input != msgSz) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// wolfSSL_send() failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_write</span></p>
    <p class="c4"><span class="c2">wolfSSL_read</span></p>
    <p class="c4"><span class="c2">wolfSSL_recv</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.9barj5la9mzr"></a><span>wolfSSL_write</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_write(WOLFSSL* ssl, const void* data, int sz);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function writes </span><span class="c2 c3">sz</span><span class="c2">&nbsp;bytes from the buffer, </span><span class="c2 c3">data</span><span class="c2">, to the SSL connection, </span><span class="c2 c3">ssl</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If necessary, wolfSSL_write() will negotiate an SSL/TLS session if the handshake has not already been performed yet by wolfSSL_connect() or wolfSSL_accept().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">wolfSSL_write() works with both blocking and non-blocking I/O. &nbsp;When the underlying I/O is non-blocking, wolfSSL_write() will return when the underlying I/O could not satisfy the needs of of wolfSSL_write() to continue. &nbsp;In this case, a call to wolfSSL_get_error() will yield either </span><span class="c2 c3">SSL_ERROR_WANT_READ</span><span class="c2">&nbsp;or </span><span class="c2 c3">SSL_ERROR_WANT_WRITE</span><span class="c2">. &nbsp;The calling process must then repeat the call to wolfSSL_write() when the underlying I/O is ready.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">If the underlying I/O is blocking, wolfSSL_write() will only return once the buffer </span><span class="c2 c3">data</span><span class="c2">&nbsp;of size </span><span class="c2 c3">sz</span><span class="c2">&nbsp;has been completely written or an error occurred.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">&gt;0</span><span class="c2">&nbsp;- the number of bytes written upon success.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">0</span><span class="c2">&nbsp;- will be returned upon failure. &nbsp;Call wolfSSL_get_error() for the specific error code.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FATAL_ERROR</span><span class="c2">&nbsp;- will be returned upon failure when either an error occurred or, when using non-blocking sockets, the SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE error was received and and the application needs to call wolfSSL_write() again. &nbsp;Use wolfSSL_get_error() to get a specific error code.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">data</span><span class="c2">&nbsp;- data buffer which will be sent to peer.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">sz</span><span class="c2">&nbsp;- size, in bytes, of data to send to the peer (</span><span class="c2 c3">data</span><span class="c2">).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">char msg[64] = &ldquo;hello wolfssl!&rdquo;;</span></p>
    <p class="c4"><span class="c0">int msgSz = (int)strlen(msg);</span></p>
    <p class="c4"><span class="c0">int flags;</span></p>
    <p class="c4"><span class="c0">int ret;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_write(ssl, msg, msgSz);</span></p>
    <p class="c4"><span class="c0">if (ret &lt;= 0) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// wolfSSL_write() failed, call wolfSSL_get_error()</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c2">See wolfSSL examples (client, server, echoclient, echoserver) for more more detailed examples of wolfSSL_write().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_send</span></p>
    <p class="c4"><span class="c2">wolfSSL_read</span></p>
    <p class="c4"><span class="c2">wolfSSL_recv</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.4ci833ts1phb"></a><span>wolfSSL_writev</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_writev(WOLFSSL* ssl, const struct iovec* iov, int iovcnt);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Simulates writev semantics but doesn&rsquo;t actually do block at a time because of SSL_write() behavior and because front adds may be small. &nbsp;Makes porting into software that uses writev easier.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">&gt;0</span><span class="c2">&nbsp;- the number of bytes written upon success.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">0</span><span class="c2">&nbsp;- will be returned upon failure. &nbsp;Call wolfSSL_get_error() for the specific error code.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_ERROR</span><span class="c2">&nbsp;will be returned if a memory error was encountered.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FATAL_ERROR</span><span class="c2">&nbsp;- will be returned upon failure when either an error occurred or, when using non-blocking sockets, the SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE error was received and and the application needs to call wolfSSL_write() again. &nbsp;Use wolfSSL_get_error() to get a specific error code.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl </span><span class="c2">- pointer to the SSL session, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">iov</span><span class="c2">&nbsp;- array of I/O vectors to write</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">iovcnt</span><span class="c2">&nbsp;- number of vectors in </span><span class="c2 c3">iov</span><span class="c2">&nbsp;array.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4"><span class="c0">char *bufA = &ldquo;hello\n&rdquo;;</span></p>
    <p class="c4"><span class="c0">char *bufB = &ldquo;hello world\n&rdquo;;</span></p>
    <p class="c4"><span class="c0">int iovcnt;</span></p>
    <p class="c4"><span class="c0">struct iovec iov[2];</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">iov[0].iov_base = buffA;</span></p>
    <p class="c4"><span class="c0">iov[0].iov_len = strlen(buffA);</span></p>
    <p class="c4"><span class="c0">iov[1].iov_base = buffB;</span></p>
    <p class="c4"><span class="c0">iov[1].iov_len = strlen(buffB);</span></p>
    <p class="c4"><span class="c0">iovcnt = 2;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_writev(ssl, iov, iovcnt);</span></p>
    <p class="c4"><span class="c0">// wrote &ldquo;ret&rdquo; bytes, or error if &lt;= 0.</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_write</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h2 class="c4 c18"><a name="h.p54j0m2uuoli"></a><span>17.9 DTLS Specific</span></h2>
    <hr>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The functions in this section are specific to using DTLS with wolfSSL.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.rlsj8qzbm9ae"></a><span>wolfSSL_dtls</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_dtls(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function is used to determine if the SSL session has been configured to use DTLS.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If the SSL session (</span><span class="c2 c3">ssl</span><span class="c2">) has been configured to use DTLS, this function will return 1, otherwise 0.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL structure, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_dtls(ssl);</span></p>
    <p class="c4"><span class="c0">if (ret) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// SSL session has been configured to use DTLS</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_dtls_get_current_timeout</span></p>
    <p class="c4"><span class="c2">wolfSSL_dtls_get_peer</span></p>
    <p class="c4"><span class="c2">wolfSSL_dtls_got_timeout</span></p>
    <p class="c4"><span class="c2">wolfSSL_dtls_set_peer</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.1uhtq8gtxcib"></a><span>wolfSSL_dtls_get_current_timeout</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">wolfSSL_dtls_get_current_timeout(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function returns the current timeout value in seconds for the WOLFSSL object. When using non-blocking sockets, something in the user code needs to decide when to check for available recv data and how long it has been waiting. The value returned by this function indicates how long the application should wait.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">The current DTLS timeout value in seconds, or </span><span class="c2 c3">NOT_COMPILED_IN</span><span class="c2">&nbsp;if wolfSSL was not built with DTLS support.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL structure, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int timeout = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">timeout = wolfSSL_get_dtls_current_timeout(ssl);</span></p>
    <p class="c4"><span class="c0">printf(&ldquo;DTLS timeout (sec) = %d\n&rdquo;, timeout);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_dtls</span></p>
    <p class="c4"><span class="c2">wolfSSL_dtls_get_peer</span></p>
    <p class="c4"><span class="c2">wolfSSL_dtls_got_timeout</span></p>
    <p class="c4"><span class="c2">wolfSSL_dtls_set_peer</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.bc4lmnixvaqb"></a><span>wolfSSL_dtls_get_peer</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_dtls_get_peer(WOLFSSL* ssl, void* peer, unsigned int* peerSz);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function gets the sockaddr_in (of size </span><span class="c2 c3">peerSz</span><span class="c2">) of the current DTLS peer. &nbsp;The function will compare peerSz to the actual DTLS peer size stored in the SSL session. &nbsp;If the peer will fit into </span><span class="c2 c3">peer</span><span class="c2">, the peer&rsquo;s sockaddr_in will be copied into </span><span class="c2 c3">peer</span><span class="c2">, with peerSz set to the size of </span><span class="c2 c3">peer</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c2 c3">SSL_SUCCESS</span><span class="c2">&nbsp;will be returned upon success.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FAILURE</span><span class="c2">&nbsp;will be returned upon failure.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_NOT_IMPLEMENTED</span><span class="c2">&nbsp;will be returned if wolfSSL was not compiled with DTLS support.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL structure, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">peer</span><span class="c2">&nbsp;- pointer to memory location to store peer&rsquo;s sockaddr_in structure.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">peerSz</span><span class="c2">&nbsp;- input/output size. &nbsp;As input, the size of the allocated memory pointed to by </span><span class="c2 c3">peer</span><span class="c2">. &nbsp;As output, the size of the actual sockaddr_in structure pointed to by </span><span class="c2 c3">peer</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl;</span></p>
    <p class="c4"><span class="c0">sockaddr_in addr;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_dtls_get_peer(ssl, &amp;addr, sizeof(addr));</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// failed to get DTLS peer</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_dtls_get_current_timeout</span></p>
    <p class="c4"><span class="c2">wolfSSL_dtls_got_timeout</span></p>
    <p class="c4"><span class="c2">wolfSSL_dtls_set_peer</span></p>
    <p class="c4"><span class="c2">wolfSSL_dtls</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.9cvqkeda3a8w"></a><span>wolfSSL_dtls_got_timeout</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int &nbsp;wolfSSL_dtls_got_timeout(WOLFSSL* ssl); &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">When using non-blocking sockets with DTLS, this function should be called on the WOLFSSL object when the controlling code thinks the transmission has timed out. It performs the actions needed to retry the last transmit, including adjusting the timeout value. If it has been too long, this will return a failure.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c2 c3">SSL_SUCCESS</span><span class="c2">&nbsp;will be returned upon success</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FATAL_ERROR</span><span class="c2">&nbsp;will be returned if there have been too many retransmissions/timeouts without getting a response from the peer.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NOT_COMPILED_IN</span><span class="c2">&nbsp;will be returned if wolfSSL was not compiled with DTLS support.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL structure, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2">See the following files for usage examples:</span></p>
    <p class="c4"><span class="c2">&lt;wolfssl_root&gt;/examples/client/client.c</span></p>
    <p class="c4"><span class="c2">&lt;wolfssl_root&gt;/examples/server/server.c</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_dtls_get_current_timeout</span></p>
    <p class="c4"><span class="c2">wolfSSL_dtls_get_peer</span></p>
    <p class="c4"><span class="c2">wolfSSL_dtls_set_peer</span></p>
    <p class="c4"><span class="c2">wolfSSL_dtls</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.td3ejguq65m6"></a><span>wolfSSL_dtls_set_peer</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_dtls_set_peer(WOLFSSL* ssl, void* peer, unsigned int peerSz);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function sets the DTLS peer, </span><span class="c2 c3">peer</span><span class="c2">&nbsp;(sockaddr_in) with size of </span><span class="c2 c3">peerSz</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c2 c3">SSL_SUCCESS</span><span class="c2">&nbsp;will be returned upon success.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FAILURE</span><span class="c2">&nbsp;will be returned upon failure.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_NOT_IMPLEMENTED</span><span class="c2">&nbsp;will be returned if wolfSSL was not compiled with DTLS support.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL structure, created using wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">peer</span><span class="c2">&nbsp;- pointer to peer&rsquo;s sockaddr_in structure.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">peerSz</span><span class="c2">&nbsp;- size of the sockaddr_in structure pointed to by </span><span class="c2 c3">peer</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl;</span></p>
    <p class="c4"><span class="c0">sockaddr_in addr;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_dtls_set_peer(ssl, &amp;addr, sizeof(addr));</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// failed to set DTLS peer</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_dtls_get_current_timeout</span></p>
    <p class="c4"><span class="c2">wolfSSL_dtls_get_peer</span></p>
    <p class="c4"><span class="c2">wolfSSL_dtls_got_timeout</span></p>
    <p class="c4"><span class="c2">wolfSSL_dtls</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h2 class="c4 c18"><a name="h.xqhbpdnjahie"></a><span>17.10 Memory Abstraction Layer</span></h2>
    <hr>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The functions in this section are used when an application sets its own memory handling functions by using the wolfSSL memory abstraction layer.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.vwl2yq73ku09"></a><span>wolfSSL_Malloc</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/wolfcrypt/memory.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void* wolfSSL_Malloc(size_t size)</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function is similar to malloc(), but calls the memory allocation function which wolfSSL has been configured to use. &nbsp;By default, wolfSSL uses malloc(). &nbsp;This can be changed using the wolfSSL memory abstraction layer - see wolfSSL_SetAllocators().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful, this function returns a pointer to allocated memory. &nbsp;If there is an error, NULL will be returned. &nbsp;Specific return values may be dependent on the underlying memory allocation function being used (if not using the default malloc()).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">size </span><span class="c2">- number of bytes to allocate.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">char* buffer;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">buffer = (char*) wolfSSL_Malloc(20);</span></p>
    <p class="c4"><span class="c0">if (buffer == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// failed to allocate memory</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_Free</span></p>
    <p class="c4"><span class="c2">wolfSSL_Realloc</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetAllocators</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.lm1h99kkdfv"></a><span>wolfSSL_Realloc</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/wolfcrypt/memory.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void* wolfSSL_Realloc(void *ptr, size_t size)</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function is similar to realloc(), but calls the memory re-allocation function which wolfSSL has been configured to use. &nbsp;By default, wolfSSL uses realloc(). &nbsp;This can be changed using the wolfSSL memory abstraction layer - see wolfSSL_SetAllocators().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful, this function returns a pointer to re-allocated memory. &nbsp;This &nbsp;may be the same pointer as </span><span class="c2 c3">ptr</span><span class="c2">, or a new pointer location. &nbsp;If there is an error, NULL will be returned. &nbsp;Specific return values may be dependent on the underlying memory re-allocation function being used (if not using the default realloc()).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ptr</span><span class="c2">&nbsp;- pointer to the previously-allocated memory, to be reallocated.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">size </span><span class="c2">- number of bytes to allocate.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">char* buffer;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">buffer = (char*) wolfSSL_Realloc(30);</span></p>
    <p class="c4"><span class="c0">if (buffer == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// failed to re-allocate memory</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_Free</span></p>
    <p class="c4"><span class="c2">wolfSSL_Malloc</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetAllocators</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.b98j75gjqgjf"></a><span>wolfSSL_Free</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/wolfcrypt/memory.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_Free(void* ptr)</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function is similar to free(), but calls the memory free function which wolfSSL has been configured to use. &nbsp;By default, wolfSSL uses free(). &nbsp;This can be changed using the wolfSSL memory abstraction layer - see wolfSSL_SetAllocators().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2">This function does not have a return value.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ptr </span><span class="c2">- pointer to the memory to be freed.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">char* buffer;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">wolfSSL_Free(buffer);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_Alloc</span></p>
    <p class="c4"><span class="c2">wolfSSL_Realloc</span></p>
    <p class="c4"><span class="c2">wolfSSL_SetAllocators</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.hbzlb4mxcoif"></a><span>wolfSSL_SetAllocators</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/wolfcrypt/memory.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_SetAllocators(wolfSSL_Malloc_cb &nbsp;malloc_function,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;wolfSSL_Free_cb free_function,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;wolfSSL_Realloc_cb realloc_function);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">typedef void *(*wolfSSL_Malloc_cb)(size_t size);</span></p>
    <p class="c4"><span class="c2">typedef void (*wolfSSL_Free_cb)(void *ptr);</span></p>
    <p class="c4"><span class="c2">typedef void *(*wolfSSL_Realloc_cb)(void *ptr, size_t size);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function registers the allocation functions used by wolfSSL. &nbsp;By default, if the system supports it, malloc/free and realloc are used. &nbsp;Using this function allows the user at runtime to install their own memory handlers.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful this function will return 0.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;is the error that will be returned if a function pointer is not provided.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">malloc_function</span><span class="c2">&nbsp;- memory allocation function for wolfSSL to use. &nbsp;Function signature must match wolfSSL_Malloc_cb prototype, above.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">free_function</span><span class="c2">&nbsp;- memory free function for wolfSSL to use. &nbsp;Function signature must match wolfSSL_Free_cb prototype, above.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">realloc_function</span><span class="c2">&nbsp;- memory re-allocation function for wolfSSL to use. &nbsp;Function signature must match wolfSSL_Realloc_cb prototype, above.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">// Memory function prototypes</span></p>
    <p class="c4"><span class="c0">void* MyMalloc(size_t size);</span></p>
    <p class="c4"><span class="c0">void &nbsp;MyFree(void* ptr);</span></p>
    <p class="c4"><span class="c0">void* MyRealloc(void* ptr, size_t size);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">// Register custom memory functions with wolfSSL</span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_SetAllocators(MyMalloc, MyFree, MyRealloc);</span></p>
    <p class="c4"><span class="c0">if (ret != 0) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// failed to set memory functions</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">void* MyMalloc(size_t size)</span></p>
    <p class="c4"><span class="c0">{</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// custom malloc function</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">void MyFree(void* ptr)</span></p>
    <p class="c4"><span class="c0">{</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// custom free function</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">void* MyRealloc(void* ptr, size_t size)</span></p>
    <p class="c4"><span class="c0">{</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// custom realloc function</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">NA</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h2 class="c4 c18"><a name="h.11ji1koaihw8"></a><span>17.11 Certificate Manager</span></h2>
    <hr>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The functions in this section are part of the wolfSSL Certificate Manager. &nbsp;The Certificate Manager allows applications to load and verify certificates external to the SSL/TLS connection.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.af6xyn8ukn2c"></a><span>wolfSSL_CertManagerDisableCRL</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_CertManagerDisableCRL(WOLFSSL_CERT_MANGER* cm);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Turns off Certificate Revocation List checking when verifying certificates with the Certificate Manager. &nbsp;By default, CRL checking is off. &nbsp;You can use this function to temporarily or permanently disable CRL checking with this Certificate Manager context that previously had CRL checking enabled.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;is the error that will be returned if a function pointer is not provided.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">cm</span><span class="c2">&nbsp;- a pointer to a WOLFSSL_CERT_MANAGER structure, created using wolfSSL_CertManagerNew().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CERT_MANAGER* cm;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CertManagerDisableCRL(cm);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error disabling cert manager</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CertManagerEnableCRL</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.1x6nm02zpjv0"></a><span>wolfSSL_CertManagerEnableCRL</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_CertManagerEnableCRL(WOLFSSL_CERT_MANGER* cm, int options);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Turns on Certificate Revocation List checking when verifying certificates with the Certificate Manager. &nbsp;By default, CRL checking is off. &nbsp;options include WOLFSSL_CRL_CHECKALL which performs CRL checking on each certificate in the chain versus the Leaf certificate only which is the default.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NOT_COMPILED_IN </span><span class="c2">will be returned if wolfSSL was not built with CRL enabled.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_E</span><span class="c2">&nbsp;will be returned if an out of memory condition occurs.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;is the error that will be returned if a pointer is not provided.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_FAILURE</span><span class="c2">&nbsp;will be returned if the CRL context cannot be initialized properly.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">cm</span><span class="c2">&nbsp;- a pointer to a WOLFSSL_CERT_MANAGER structure, created using wolfSSL_CertManagerNew().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">options</span><span class="c2">&nbsp;- options to use when enabling the Certification Manager, </span><span class="c2 c3">cm</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CERT_MANAGER* cm;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CertManagerEnableCRL(cm, 0);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error enabling cert manager</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CertManagerDisableCRL</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.lyxixwel26rt"></a><span>wolfSSL_CertManagerFree</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_CertManagerFree(WOLFSSL_CERT_MANGER* cm);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Frees all resources associated with the Certificate Manager context. &nbsp;Call this when you no longer need to use the Certificate Manager.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">No return value is used.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">cm</span><span class="c2">&nbsp;- a pointer to a WOLFSSL_CERT_MANAGER structure, created using wolfSSL_CertManagerNew().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_CERT_MANAGER* cm;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">wolfSSL_CertManagerFree(cm);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CertManagerNew</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.qpei9rgz6fmc"></a><span>wolfSSL_CertManagerLoadCA</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_CertManagerLoadCA(WOLFSSL_CERT_MANGER* cm, const char* CAfile,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const &nbsp;char* CApath);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Specifies the locations for CA certificate loading into the manager context. &nbsp;The PEM certificate CAfile may contain several trusted CA certificates. &nbsp;If CApath is not NULL it specifies a directory containing CA certificates in PEM format.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILETYPE</span><span class="c2">&nbsp;will be returned if the file is the wrong format.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILE</span><span class="c2">&nbsp;will be returned if the file doesn&rsquo;t exist, can&rsquo;t be read, or is corrupted.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_E</span><span class="c2">&nbsp;will be returned if an out of memory condition occurs.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ASN_INPUT_E</span><span class="c2">&nbsp;will be returned if Base16 decoding fails on the file.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;is the error that will be returned if a pointer is not provided.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">cm</span><span class="c2">&nbsp;- a pointer to a WOLFSSL_CERT_MANAGER structure, created using wolfSSL_CertManagerNew().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">CAfile</span><span class="c2">&nbsp;- pointer to the name of the file containing CA certificates to load.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">CApath</span><span class="c2">&nbsp;- pointer to the name of a directory path containing CA certificates to load. &nbsp;The NULL pointer may be used if no certificate directory is desired.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CERT_MANAGER* cm;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CertManagerLoadCA(cm, &ldquo;path/to/cert-file.pem&rdquo;, 0);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error loading CA certs into cert manager</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CertManagerVerify</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.x5sljr29tg1n"></a><span>wolfSSL_CertManagerNew</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">WOLFSSL_CERT_MANAGER* wolfSSL_CertManagerNew(void);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Allocates and initializes a new Certificate Manager context. &nbsp;This context be used independent of SSL needs. &nbsp;It may be used to load certificates, verify certificates, and check the revocation status.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return a valid WOLFSSL_CERT_MANAGER pointer.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">NULL</span><span class="c2">&nbsp;will be returned for an error state.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2">There are no parameters for this function.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">WOLFSSL_CERT_MANAGER* cm;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">cm = wolfSSL_CertManagerNew();</span></p>
    <p class="c4"><span class="c0">if (cm == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error creating new cert manager</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CertManagerFree</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.ykj84golbfbi"></a><span>wolfSSL_CertManagerVerify</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_CertManagerVerify(WOLFSSL_CERT_MANGER* cm, const char* cert,</span></p>
    <p class="c4 c23"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; int format);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Specifies the certificate to verify with the Certificate Manager context. &nbsp;The format can be SSL_FILETYPE_PEM or SSL_FILETYPE_ASN1.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ASN_SIG_CONFIRM_E</span><span class="c2">&nbsp;will be returned if the signature could not be verified.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ASN_SIG_OID_E</span><span class="c2">&nbsp;will be returned if the signature type is not supported.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">CRL_CERT_REVOKED</span><span class="c2">&nbsp;is an error that is returned if this certificate has been revoked.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">CRL_MISSING</span><span class="c2">&nbsp;is an error that is returned if a current issuer CRL is not available.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ASN_BEFORE_DATE_E</span><span class="c2">&nbsp;will be returned if the current date is before the before date.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ASN_AFTER_DATE_E</span><span class="c2">&nbsp;will be returned if the current date is after the after date.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILETYPE</span><span class="c2">&nbsp;will be returned if the file is the wrong format.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILE</span><span class="c2">&nbsp;will be returned if the file doesn&rsquo;t exist, can&rsquo;t be read, or is corrupted.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_E</span><span class="c2">&nbsp;will be returned if an out of memory condition occurs.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ASN_INPUT_E</span><span class="c2">&nbsp;will be returned if Base16 decoding fails on the file.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;is the error that will be returned if a pointer is not provided.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">cm</span><span class="c2">&nbsp;- a pointer to a WOLFSSL_CERT_MANAGER structure, created using wolfSSL_CertManagerNew().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">cert</span><span class="c2">&nbsp;- pointer to the name of the file containing the certificates to verify.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">format</span><span class="c2">&nbsp;- format of the certificate to verify - either SSL_FILETYPE_ASN1 or SSL_FILETYPE_PEM.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CERT_MANAGER* cm;</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CertManagerVerify(cm, &ldquo;path/to/cert-file.pem&rdquo;, SSL_FILETYPE_PEM);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error verifying certificate</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CertManagerLoadCA</span></p>
    <p class="c4"><span class="c2">wolfSSL_CertManagerVerifyBuffer</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.q0vp3jdbwp66"></a><span>wolfSSL_CertManagerVerifyBuffer</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_CertManagerVerify(WOLFSSL_CERT_MANGER* cm,</span></p>
    <p class="c4 c23"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; const unsigned char* buff, int sz, int format);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Specifies the certificate buffer to verify with the Certificate Manager context. &nbsp;The format can be SSL_FILETYPE_PEM or SSL_FILETYPE_ASN1.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ASN_SIG_CONFIRM_E</span><span class="c2">&nbsp;will be returned if the signature could not be verified.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ASN_SIG_OID_E</span><span class="c2">&nbsp;will be returned if the signature type is not supported.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">CRL_CERT_REVOKED</span><span class="c2">&nbsp;is an error that is returned if this certificate has been revoked.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">CRL_MISSING</span><span class="c2">&nbsp;is an error that is returned if a current issuer CRL is not available.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ASN_BEFORE_DATE_E</span><span class="c2">&nbsp;will be returned if the current date is before the before date.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ASN_AFTER_DATE_E</span><span class="c2">&nbsp;will be returned if the current date is after the after date.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILETYPE</span><span class="c2">&nbsp;will be returned if the file is the wrong format.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILE</span><span class="c2">&nbsp;will be returned if the file doesn&rsquo;t exist, can&rsquo;t be read, or is corrupted.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_E</span><span class="c2">&nbsp;will be returned if an out of memory condition occurs.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">ASN_INPUT_E</span><span class="c2">&nbsp;will be returned if Base16 decoding fails on the file.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;is the error that will be returned if a pointer is not provided.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">cm</span><span class="c2">&nbsp;- a pointer to a WOLFSSL_CERT_MANAGER structure, created using wolfSSL_CertManagerNew().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">buff</span><span class="c2">&nbsp;- buffer containing the certificates to verify.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">sz</span><span class="c2">&nbsp;- size of the buffer, </span><span class="c2 c3">buf</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">format</span><span class="c2">&nbsp;- format of the certificate to verify, located in </span><span class="c2 c3">buf</span><span class="c2">&nbsp;- either SSL_FILETYPE_ASN1 or SSL_FILETYPE_PEM.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">int sz = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CERT_MANAGER* cm;</span></p>
    <p class="c4"><span class="c0">byte certBuff[...];</span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CertManagerVerifyBuffer(cm, certBuff, sz, SSL_FILETYPE_PEM);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error verifying certificate</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CertManagerLoadCA</span></p>
    <p class="c4"><span class="c2">wolfSSL_CertManagerVerify</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h2 class="c4 c18"><a name="h.qmod5ysve8ld"></a><span>17.12 OpenSSL Compatibility Layer</span></h2>
    <hr>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The functions in this section are part of wolfSSL&rsquo;s OpenSSL Compatibility Layer. &nbsp;These functions are only available when wolfSSL has been compiled with the OPENSSL_EXTRA define.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.kgw0q88zbek8"></a><span>wolfSSL_X509_get_serial_number</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int &nbsp;wolfSSL_X509_get_serial_number(WOLFSSL_X509* x509, unsigned char* in,</span></p>
    <p class="c4 c24"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* inOutSz);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Retrieves the peer&rsquo;s certificate serial number. &nbsp;The serial number buffer (</span><span class="c2 c3">in</span><span class="c2">) should be at least 32 bytes long and be provided as the </span><span class="c2 c3">*inOutSz</span><span class="c2">&nbsp;argument as input. &nbsp;After calling the function </span><span class="c2 c3">*inOutSz</span><span class="c2">&nbsp;will hold the actual length in bytes written to the </span><span class="c2 c3">in</span><span class="c2">&nbsp;buffer.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;will be returned if a bad function argument was encountered.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">SSL_get_peer_certificate</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.ze7h5w1jxq8w"></a><span>wolfSSL_get_sessionID</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">const unsigned char* wolfSSL_get_sessionID(const WOLFSSL_SESSION* session);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Retrieves the session&rsquo;s ID. &nbsp;The session ID is always 32 bytes long. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">The session ID.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">SSL_get_session()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.u8w3ufc6kwb4"></a><span>wolfSSL_get_peer_chain</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">WOLFSSL_X509_CHAIN* wolfSSL_get_peer_chain(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Retrieves the peer&rsquo;s certificate chain. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return the peer&rsquo;s certificate chain.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">0</span><span class="c2">&nbsp;will be returned if an invalid WOLFSSL pointer is passed to the function.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_chain_count</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_chain_length</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_chain_cert</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_chain_cert_pem</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.8lmy79daav40"></a><span>wolfSSL_get_chain_count</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_get_chain_count(WOLFSSL_X509_CHAIN* chain);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Retrieves the peer&rsquo;s certificate chain count.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return the peer&rsquo;s certificate chain count.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">0</span><span class="c2">&nbsp;will be returned if an invalid chain pointer is passed to the function.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_peer_chain</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_chain_length</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_chain_cert</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_chain_cert_pem</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.xbs7pbvfsgm4"></a><span>wolfSSL_get_chain_length</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_get_chain_length(WOLFSSL_X509_CHAIN* chain, int idx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Retrieves the peer&rsquo;s ASN1.DER certificate length in bytes at index (</span><span class="c2 c3">idx</span><span class="c2">).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return the peer&rsquo;s certificate length in bytes by index.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">0</span><span class="c2">&nbsp;will be returned if an invalid chain pointer is passed to the function.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_peer_chain</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_chain_count</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_chain_cert</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_chain_cert_pem</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.6i4x4fdjx47z"></a><span>wolfSSL_get_chain_cert</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">unsigned char* wolfSSL_get_chain_cert(WOLFSSL_X509_CHAIN* chain, int idx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Retrieves the peer&rsquo;s ASN1.DER certificate at index (</span><span class="c2 c3">idx</span><span class="c2">).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return the peer&rsquo;s certificate by index.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">0</span><span class="c2">&nbsp;will be returned if an invalid chain pointer is passed to the function.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_peer_chain</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_chain_count</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_chain_length</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_chain_cert_pem</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.i47uoh95cfop"></a><span>wolfSSL_get_chain_cert_pem</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">unsigned char* wolfSSL_get_chain_cert_pem(WOLFSSL_X509_CHAIN* chain, int idx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Retrieves the peer&rsquo;s PEM certificate at index (</span><span class="c2 c3">idx</span><span class="c2">).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return the peer&rsquo;s certificate by index.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">0</span><span class="c2">&nbsp;will be returned if an invalid chain pointer is passed to the function.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_peer_chain</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_chain_count</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_chain_length</span></p>
    <p class="c4"><span class="c2">wolfSSL_get_chain_cert</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.etkpb1kk27n8"></a><span>wolfSSL_PemCertToDer</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_PemCertToDer(const char* fileName, unsigned char* derBuffer, int derSz);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">Loads the PEM certificate from </span><span class="c2 c3">fileName</span><span class="c2">&nbsp;and converts it into DER format, placing the result into </span><span class="c2 c3">derBuffer</span><span class="c2">&nbsp;which is of size </span><span class="c2 c3">derSz</span><span class="c2">. &nbsp;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return the number of bytes written to </span><span class="c2 c3">derBuffer</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_BAD_FILE</span><span class="c2">&nbsp;will be returned if the file doesn&rsquo;t exist, can&rsquo;t be read, or is corrupted.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_E</span><span class="c2">&nbsp;will be returned if an out of memory condition occurs.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">SSL_NO_PEM_HEADER</span><span class="c2">&nbsp;will be returned if the PEM certificate header can&rsquo;t be found.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BUFFER_E</span><span class="c2">&nbsp;will be returned if a chain buffer is bigger than the receiving buffer.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">filename</span><span class="c2">&nbsp;- pointer to the name of the PEM-formatted certificate for conversion.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">derBuffer</span><span class="c2">&nbsp;- the buffer for which the converted PEM certificate will be placed in DER format.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">derSz</span><span class="c2">&nbsp;- size of derBuffer.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int derSz;</span></p>
    <p class="c4"><span class="c0">byte derBuf[...];</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">derSz = wolfSSL_PemCertToDer(&ldquo;./cert.pem&rdquo;, derBuf, sizeof(derBuf));</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">SSL_get_peer_certificate</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.34g8uc73jf0"></a><span>wolfSSL_CTX_use_RSAPrivateKey_file</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_CTX_use_RSAPrivateKey_file(WOLFSSL_CTX* ctx,const char* file,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int format);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function loads the private RSA key used in the SSL connection into the SSL context (WOLFSSL_CTX). &nbsp;This function is only available when wolfSSL has been compiled with the OpenSSL compatibility layer enabled (--enable-opensslExtra, #define OPENSSL_EXTRA), and is identical to the more-typically used wolfSSL_CTX_use_PrivateKey_file() function.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The </span><span class="c2 c3">file</span><span class="c2">&nbsp;argument contains a pointer to the RSA private key file, in the format specified by </span><span class="c2 c3">format</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">, otherwise </span><span class="c2 c3">SSL_FAILURE</span><span class="c2">&nbsp;will be returned. &nbsp;If the function call fails, possible causes might include:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">- The input key file is in the wrong format, or the wrong format has been given using the &ldquo;format&rdquo; argument</span></p>
    <p class="c4"><span class="c2">- file doesn&rsquo;t exist, can&rsquo;t be read, or is corrupted</span></p>
    <p class="c4"><span class="c2">- an out of memory condition occurs</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx</span><span class="c2">&nbsp;- a pointer to a WOLFSSL_CTX structure, created using wolfSSL_CTX_new()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">file</span><span class="c2">&nbsp;- a pointer to the name of the file containing the RSA private key to be loaded into the wolfSSL SSL context, with format as specified by </span><span class="c2 c3">format</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">format</span><span class="c2">&nbsp;- the encoding type of the RSA private key specified by </span><span class="c2 c3">file</span><span class="c2">. &nbsp;Possible values include SSL_FILETYPE_PEM and SSL_FILETYPE_ASN1.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CTX_use_RSAPrivateKey_file(ctx, &ldquo;./server-key.pem&rdquo;,</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SSL_FILETYPE_PEM);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error loading private key file</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_PrivateKey_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_PrivateKey_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_RSAPrivateKey_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_PrivateKey_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_PrivateKey_file</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.r8vf20vy82ic"></a><span>wolfSSL_use_certificate_file</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_use_certificate_file(WOLFSSL* ssl, const char* file, int format);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function loads a certificate file into the SSL session (WOLFSSL structure). &nbsp;The certificate file is provided by the </span><span class="c2 c3">file</span><span class="c2">&nbsp;argument. &nbsp;The </span><span class="c2 c3">format</span><span class="c2">&nbsp;argument specifies the format type of the file - either </span><span class="c2 c3">SSL_FILETYPE_ASN1 </span><span class="c2">or </span><span class="c2 c3">SSL_FILETYPE_PEM</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">, otherwise </span><span class="c2 c3">SSL_FAILURE</span><span class="c2">&nbsp;will be returned. &nbsp;If the function call fails, possible causes might include:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">- The file is in the wrong format, or the wrong format has been given using the &ldquo;format&rdquo; argument</span></p>
    <p class="c4"><span class="c2">- file doesn&rsquo;t exist, can&rsquo;t be read, or is corrupted</span></p>
    <p class="c4"><span class="c2">- an out of memory condition occurs</span></p>
    <p class="c4"><span class="c2">- Base16 decoding fails on the file</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL structure, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">file</span><span class="c2">&nbsp;- a pointer to the name of the file containing the certificate to be loaded into the wolfSSL SSL session, with format as specified by </span><span class="c2 c3">format</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">format</span><span class="c2">&nbsp;- the encoding type of the certificate specified by </span><span class="c2 c3">file</span><span class="c2">. &nbsp;Possible values include SSL_FILETYPE_PEM and SSL_FILETYPE_ASN1.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_use_certificate_file(ssl, &ldquo;./client-cert.pem&rdquo;,</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SSL_FILETYPE_PEM);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error loading cert file</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_certificate_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_certificate_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_certificate_buffer</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.b58lmlqy0igi"></a><span>wolfSSL_use_PrivateKey_file</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_use_PrivateKey_file(WOLFSSL* ssl, const char* file, int format);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function loads a private key file into the SSL session (WOLFSSL structure). &nbsp;The key file is provided by the </span><span class="c2 c3">file</span><span class="c2">&nbsp;argument. &nbsp;The </span><span class="c2 c3">format</span><span class="c2">&nbsp;argument specifies the format type of the file - </span><span class="c2 c3">SSL_FILETYPE_ASN1 </span><span class="c2">or </span><span class="c2 c3">SSL_FILETYPE_PEM</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">, otherwise </span><span class="c2 c3">SSL_FAILURE</span><span class="c2">&nbsp;will be returned. &nbsp;If the function call fails, possible causes might include:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">- The file is in the wrong format, or the wrong format has been given using the &ldquo;format&rdquo; argument</span></p>
    <p class="c4"><span class="c2">- The file doesn&rsquo;t exist, can&rsquo;t be read, or is corrupted</span></p>
    <p class="c4"><span class="c2">- An out of memory condition occurs</span></p>
    <p class="c4"><span class="c2">- Base16 decoding fails on the file</span></p>
    <p class="c4"><span class="c2">- The key file is encrypted but no password is provided</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL structure, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">file</span><span class="c2">&nbsp;- a pointer to the name of the file containing the key file to be loaded into the wolfSSL SSL session, with format as specified by </span><span class="c2 c3">format</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">format</span><span class="c2">&nbsp;- the encoding type of the key specified by </span><span class="c2 c3">file</span><span class="c2">. &nbsp;Possible values include SSL_FILETYPE_PEM and SSL_FILETYPE_ASN1.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_use_PrivateKey_file(ssl, &ldquo;./server-key.pem&rdquo;,</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SSL_FILETYPE_PEM);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error loading key file</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_PrivateKey_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_PrivateKey_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_PrivateKey_buffer</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.jpkctt54splk"></a><span>wolfSSL_use_certificate_chain_file</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_use_certificate_chain_file(WOLFSSL* ssl, const char* file);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function loads a chain of certificates into the SSL session (WOLFSSL structure). &nbsp;The file containing the certificate chain is provided by the </span><span class="c2 c3">file</span><span class="c2">&nbsp;argument, and must contain PEM-formatted certificates. &nbsp;This function will process up to MAX_CHAIN_DEPTH (default = 9, defined in internal.h) certificates, plus the subject certificate.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">, otherwise </span><span class="c2 c3">SSL_FAILURE</span><span class="c2">&nbsp;will be returned. &nbsp;If the function call fails, possible causes might include:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">- The file is in the wrong format, or the wrong format has been given using the &ldquo;format&rdquo; argument</span></p>
    <p class="c4"><span class="c2">- file doesn&rsquo;t exist, can&rsquo;t be read, or is corrupted</span></p>
    <p class="c4"><span class="c2">- an out of memory condition occurs</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL structure, created using wolfSSL_new()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">file</span><span class="c2">&nbsp;- a pointer to the name of the file containing the chain of certificates to be loaded into the wolfSSL SSL session. &nbsp;Certificates must be in PEM format.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ctx;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_use_certificate_chain_file(ssl, &ldquo;./cert-chain.pem&rdquo;);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error loading cert file</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_certificate_chain_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_certificate_chain_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_certificate_chain_buffer</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.jb4tyd7fliov"></a><span>wolfSSL_use_RSAPrivateKey_file</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_use_RSAPrivateKey_file(WOLFSSL* ssl,const char* file, int format);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function loads the private RSA key used in the SSL connection into the SSL session (WOLFSSL structure). &nbsp;This function is only available when wolfSSL has been compiled with the OpenSSL compatibility layer enabled (--enable-opensslExtra, #define OPENSSL_EXTRA), and is identical to the more-typically used wolfSSL_use_PrivateKey_file() function.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The </span><span class="c2 c3">file</span><span class="c2">&nbsp;argument contains a pointer to the RSA private key file, in the format specified by </span><span class="c2 c3">format</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">, otherwise </span><span class="c2 c3">SSL_FAILURE</span><span class="c2">&nbsp;will be returned. &nbsp;If the function call fails, possible causes might include:</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">- The input key file is in the wrong format, or the wrong format has been given using the &ldquo;format&rdquo; argument</span></p>
    <p class="c4"><span class="c2">- file doesn&rsquo;t exist, can&rsquo;t be read, or is corrupted</span></p>
    <p class="c4"><span class="c2">- an out of memory condition occurs</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- a pointer to a WOLFSSL structure, created using wolfSSL_new()</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">file</span><span class="c2">&nbsp;- a pointer to the name of the file containing the RSA private key to be loaded into the wolfSSL SSL session, with format as specified by </span><span class="c2 c3">format</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">format</span><span class="c2">&nbsp;- the encoding type of the RSA private key specified by </span><span class="c2 c3">file</span><span class="c2">. &nbsp;Possible values include SSL_FILETYPE_PEM and SSL_FILETYPE_ASN1.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_use_RSAPrivateKey_file(ssl, &ldquo;./server-key.pem&rdquo;,</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SSL_FILETYPE_PEM);</span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error loading private key file</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_RSAPrivateKey_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_PrivateKey_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_use_PrivateKey_file</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_PrivateKey_buffer</span></p>
    <p class="c4"><span class="c2">wolfSSL_use_PrivateKey_file</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h2 class="c4 c18"><a name="h.ky0z2b51n3eo"></a><span>17.13 TLS Extensions</span></h2>
    <hr>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">The functions in this section are specific to supported TLS extensions.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.5ayg9hsdf8ky"></a><span>wolfSSL_CTX_UseSNI</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_CTX_UseSNI(WOLFSSL_CTX* ctx, unsigned char type, const void* data, unsigned short size);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function enables the use of Server Name Indication for SSL objects created from the SSL context passed in the &#39;ctx&#39; parameter. It means that the SNI extension will be sent on ClientHello by wolfSSL clients and wolfSSL servers will respond ClientHello + SNI with either ServerHello + blank SNI or alert fatal in case of SNI mismatch.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;is the error that will be returned in one of these cases:</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; * ctx is NULL</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; * data is NULL</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; * type is a unknown value. (see below)</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_E</span><span class="c2">&nbsp;is the error returned when there is not enough memory.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx</span><span class="c2">&nbsp;- pointer to a SSL context, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">type</span><span class="c2">&nbsp;- indicates which type of server name is been passed in data. The known types are:</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; enum {</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; WOLFSSL_SNI_HOST_NAME = 0</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; };</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">data</span><span class="c2">&nbsp;- pointer to the server name data.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">size</span><span class="c2">&nbsp;- size of the server name data.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx = 0;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ctx == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // context creation failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CTX_UseSNI(ctx, WOLFSSL_SNI_HOST_NAME, &quot;www.yassl.com&quot;, strlen(&quot;www.yassl.com&quot;));</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ret != 0) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // sni usage failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4"><span class="c2">wolfSSL_UseSNI</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.4rh5qnuyj3gi"></a><span>wolfSSL_UseSNI</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_UseSNI(WOLFSSL* ssl, unsigned char type, const void* data, unsigned short size);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function enables the use of Server Name Indication in the SSL object passed in the &#39;ssl&#39; parameter. It means that the SNI extension will be sent on ClientHello by wolfSSL client and wolfSSL server will respond ClientHello + SNI with either ServerHello + blank SNI or alert fatal in case of SNI mismatch.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;is the error that will be returned in one of these cases:</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; * ssl is NULL</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; * data is NULL</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; * type is a unknown value. (see below)</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_E</span><span class="c2">&nbsp;is the error returned when there is not enough memory.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- pointer to a SSL object, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">type</span><span class="c2">&nbsp;- indicates which type of server name is been passed in data. The known types are:</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; enum {</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; WOLFSSL_SNI_HOST_NAME = 0</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; };</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">data</span><span class="c2">&nbsp;- pointer to the server name data.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">size</span><span class="c2">&nbsp;- size of the server name data.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ctx == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // context creation failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ssl = wolfSSL_new(ctx);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ssl == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // ssl creation failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_UseSNI(ssl, WOLFSSL_SNI_HOST_NAME, &quot;www.yassl.com&quot;, strlen(&quot;www.yassl.com&quot;));</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ret != 0) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // sni usage failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_new</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_UseSNI</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.buo15e2faknw"></a><span>wolfSSL_CTX_SNI_SetOptions</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_CTX_SNI_SetOptions(WOLFSSL_CTX* ctx, unsigned char type, unsigned char options);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function is called on the server side to configure the behavior of the SSL sessions using Server Name Indication for SSL objects created from the SSL context passed in the &#39;ctx&#39; parameter. The options are explained below.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">This function does not have a return value.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx</span><span class="c2">&nbsp;- pointer to a SSL context, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">type</span><span class="c2">&nbsp;- indicates which type of server name is been passed in data. The known types are:</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; enum {</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; WOLFSSL_SNI_HOST_NAME = 0</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; };</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">options</span><span class="c2">&nbsp;- a bitwise semaphore with the chosen options. The available options are:</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; enum {</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; WOLFSSL_SNI_CONTINUE_ON_MISMATCH = 0x01,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; WOLFSSL_SNI_ANSWER_ON_MISMATCH &nbsp; = 0x02</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; };</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; </span></p>
    <p class="c4"><span class="c2">Normally the server will abort the handshake by sending a fatal-level unrecognized_name(112) alert if the hostname provided by the client mismatch with the servers.</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; </span></p>
    <p class="c4"><span class="c2 c3">WOLFSSL_SNI_CONTINUE_ON_MISMATCH</span><span class="c2">&nbsp;- With this option set, the server will not send a SNI response instead of aborting the session.</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; </span></p>
    <p class="c4"><span class="c2 c3">WOLFSSL_SNI_ANSWER_ON_MISMATCH</span><span class="c2">&nbsp;- With this option set, the server will send a SNI response as if the host names match instead of aborting the session.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx = 0;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ctx == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // context creation failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CTX_UseSNI(ctx, 0, &quot;www.yassl.com&quot;, strlen(&quot;www.yassl.com&quot;));</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ret != 0) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // sni usage failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">wolfSSL_CTX_SNI_SetOptions(ctx, WOLFSSL_SNI_HOST_NAME, WOLFSSL_SNI_CONTINUE_ON_MISMATCH);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_UseSNI</span></p>
    <p class="c4"><span class="c2">wolfSSL_SNI_SetOptions</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.w7xzskcbyhuc"></a><span>wolfSSL_SNI_SetOptions</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">void wolfSSL_SNI_SetOptions(WOLFSSL* ssl, unsigned char type, unsigned char options);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function is called on the server side to configure the behavior of the SSL session using Server Name Indication in the SSL object passed in the &#39;ssl&#39; parameter. The options are explained below.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">This function does not have a return value.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- pointer to a SSL object, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">type</span><span class="c2">&nbsp;- indicates which type of server name is been passed in data. The known types are:</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; enum {</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; WOLFSSL_SNI_HOST_NAME = 0</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; };</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">options</span><span class="c2">&nbsp;- a bitwise semaphore with the chosen options. The available options are:</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; enum {</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; WOLFSSL_SNI_CONTINUE_ON_MISMATCH = 0x01,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; WOLFSSL_SNI_ANSWER_ON_MISMATCH &nbsp; = 0x02</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; };</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; </span></p>
    <p class="c4"><span class="c2">Normally the server will abort the handshake by sending a fatal-level unrecognized_name(112) alert if the hostname provided by the client mismatch with the servers.</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; </span></p>
    <p class="c4"><span class="c2 c3">WOLFSSL_SNI_CONTINUE_ON_MISMATCH</span><span class="c2">&nbsp;- With this option set, the server will not send a SNI response instead of aborting the session.</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; </span></p>
    <p class="c4"><span class="c2 c3">WOLFSSL_SNI_ANSWER_ON_MISMATCH</span><span class="c2">&nbsp;- With this option set, the server will send a SNI response as if the host names match instead of aborting the session.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ctx == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // context creation failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ssl = wolfSSL_new(ctx);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ssl == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // ssl creation failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_UseSNI(ssl, 0, &quot;www.yassl.com&quot;, strlen(&quot;www.yassl.com&quot;));</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ret != 0) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // sni usage failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">wolfSSL_SNI_SetOptions(ssl, WOLFSSL_SNI_HOST_NAME, WOLFSSL_SNI_CONTINUE_ON_MISMATCH);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_new</span></p>
    <p class="c4"><span class="c2">wolfSSL_UseSNI</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_SNI_SetOptions</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.l5teg5ze70fy"></a><span>wolfSSL_SNI_GetRequest</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">unsigned short wolfSSL_SNI_GetRequest(WOLFSSL *ssl, unsigned char type, void** data);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function is called on the server side to retrieve the Server Name Indication provided by the client in a SSL session.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">The size of the provided SNI data.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- pointer to a SSL object, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">type</span><span class="c2">&nbsp;- indicates which type of server name is been retrieved in data. The known types are:</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; enum {</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; WOLFSSL_SNI_HOST_NAME = 0</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; };</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">data</span><span class="c2">&nbsp;- pointer to the data provided by the client.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ctx == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // context creation failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ssl = wolfSSL_new(ctx);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ssl == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // ssl creation failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_UseSNI(ssl, 0, &quot;www.yassl.com&quot;, strlen(&quot;www.yassl.com&quot;));</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ret != 0) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // sni usage failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (wolfSSL_accept(ssl) == SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; void *data = NULL;</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; unsigned short size = wolfSSL_SNI_GetRequest(ssl, 0, &amp;data);</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_UseSNI</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_UseSNI</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.4ul8xots4ttd"></a><span>wolfSSL_SNI_GetFromBuffer</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">WOLFSSL_API int wolfSSL_SNI_GetFromBuffer(const unsigned char* clientHello, unsigned int helloSz, unsigned char type, unsigned char* sni, unsigned int* inOutSz);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function is called on the server side to retrieve the Server Name Indication provided by the client from the Client Hello message sent by the client to start a session. It does not requires context or session setup to retrieve the SNI.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">;</span></p>
    <p class="c4"><span class="c2">If there is no SNI extension in the client hello, the call will return </span><span class="c2 c3">0</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;is the error that will be returned in one of this cases:</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; * buffer is NULL</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; * bufferSz &lt;= 0</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; * sni is NULL</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; * inOutSz is NULL or &lt;= 0</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BUFFER_ERROR</span><span class="c2">&nbsp;is the error returned when there is a malformed Client Hello message.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">INCOMPLETE_DATA</span><span class="c2">&nbsp;is the error returned when there is not enough data to complete the extraction.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">buffer</span><span class="c2">&nbsp;- pointer to the data provided by the client (Client Hello).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">bufferSz</span><span class="c2">&nbsp;- size of the Client Hello message.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">type</span><span class="c2">&nbsp;- indicates which type of server name is been retrieved from the buffer. The known types are:</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; enum {</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; WOLFSSL_SNI_HOST_NAME = 0</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; };</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">sni</span><span class="c2">&nbsp;- pointer to where the output is going to be stored.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">inOutSz</span><span class="c2">&nbsp;- pointer to the output size, this value will be updated to MIN(&quot;SNI&#39;s length&quot;, inOutSz).</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">unsigned char buffer[1024] = {0};</span></p>
    <p class="c4"><span class="c0">unsigned char result[32] &nbsp; = {0};</span></p>
    <p class="c4"><span class="c0">int &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; length &nbsp; &nbsp; &nbsp; = 32;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">// read Client Hello to buffer...</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_SNI_GetFromBuffer(buffer, sizeof(buffer), 0, result, &amp;length));</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ret != SSL_SUCCESS) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // sni retrieve failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_UseSNI</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_UseSNI</span></p>
    <p class="c4"><span class="c2">wolfSSL_SNI_GetRequest</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.z1l4j0fthl2d"></a><span>wolfSSL_CTX_UseMaxFragment</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_CTX_UseMaxFragment(WOLFSSL_CTX* ctx, unsigned char mfl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function is called on the client side to enable the use of Maximum Fragment Length for SSL objects created from the SSL context passed in the &#39;ctx&#39; parameter. It means that the Maximum Fragment Length extension will be sent on ClientHello by wolfSSL clients.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;is the error that will be returned in one of these cases:</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; * ctx is NULL</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; * mfl is out of range.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_E</span><span class="c2">&nbsp;is the error returned when there is not enough memory.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx</span><span class="c2">&nbsp;- pointer to a SSL context, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">mfl</span><span class="c2">&nbsp;- indicates which is the Maximum Fragment Length requested for the session. The available options are:</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; enum {</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; WOLFSSL_MFL_2_9 &nbsp;= 1, /* &nbsp;512 bytes */</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; WOLFSSL_MFL_2_10 = 2, /* 1024 bytes */</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; WOLFSSL_MFL_2_11 = 3, /* 2048 bytes */</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; WOLFSSL_MFL_2_12 = 4, /* 4096 bytes */</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; WOLFSSL_MFL_2_13 = 5 &nbsp;/* 8192 bytes *//* wolfSSL ONLY!!! */</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; };</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx = 0;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ctx == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // context creation failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CTX_UseMaxFragment(ctx, WOLFSSL_MFL_2_11);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ret != 0) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // max fragment usage failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4"><span class="c2">wolfSSL_UseMaxFragment</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.y917latf40b7"></a><span>wolfSSL_UseMaxFragment</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_UseMaxFragment(WOLFSSL* ssl, unsigned char mfl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function is called on the client side to enable the use of Maximum Fragment Length in the SSL object passed in the &#39;ssl&#39; parameter. It means that the Maximum Fragment Length extension will be sent on ClientHello by wolfSSL clients.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;is the error that will be returned in one of these cases:</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; * ssl is NULL</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; * mfl is out of range.</span></p>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_E</span><span class="c2">&nbsp;is the error returned when there is not enough memory.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- pointer to a SSL object, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">mfl</span><span class="c2">&nbsp;- indicates witch is the Maximum Fragment Length requested for the session. The available options are:</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; enum {</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; WOLFSSL_MFL_2_9 &nbsp;= 1, /* &nbsp;512 bytes */</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; WOLFSSL_MFL_2_10 = 2, /* 1024 bytes */</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; WOLFSSL_MFL_2_11 = 3, /* 2048 bytes */</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; WOLFSSL_MFL_2_12 = 4, /* 4096 bytes */</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; WOLFSSL_MFL_2_13 = 5 &nbsp;/* 8192 bytes *//* wolfSSL ONLY!!! */</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; };</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ctx == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // context creation failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ssl = wolfSSL_new(ctx);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ssl == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // ssl creation failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_UseMaxFragment(ssl, WOLFSSL_MFL_2_11);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ret != 0) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // max fragment usage failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_new</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_UseMaxFragment</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.ukansau8wtrg"></a><span>wolfSSL_CTX_UseTruncatedHMAC</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_CTX_UseTruncatedHMAC(WOLFSSL_CTX* ctx);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function is called on the client side to enable the use of Truncated HMAC for SSL objects created from the SSL context passed in the &#39;ctx&#39; parameter. It means that the Truncated HMAC extension will be sent on ClientHello by wolfSSL clients.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;is the error that will be returned in one of these cases:</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; * ctx is NULL</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_E</span><span class="c2">&nbsp;is the error returned when there is not enough memory.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx</span><span class="c2">&nbsp;- pointer to a SSL context, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx = 0;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ctx == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // context creation failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CTX_UseTruncatedHMAC(ctx);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ret != 0) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // truncated HMAC usage failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4"><span class="c2">wolfSSL_UseMaxFragment</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.m4n304gfi28"></a><span>wolfSSL_UseTruncatedHMAC</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_UseTruncatedHMAC(WOLFSSL* ssl);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function is called on the client side to enable the use of Truncated HMAC in the SSL object passed in the &#39;ssl&#39; parameter. It means that the Truncated HMAC extension will be sent on ClientHello by wolfSSL clients.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;is the error that will be returned in one of these cases:</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; * ssl is NULL</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_E</span><span class="c2">&nbsp;is the error returned when there is not enough memory.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- pointer to a SSL object, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ctx == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // context creation failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ssl = wolfSSL_new(ctx);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ssl == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // ssl creation failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_UseTruncatedHMAC(ssl);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ret != 0) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // truncated HMAC usage failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_new</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_UseMaxFragment</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.v8htxogcf7cs"></a><span>wolfSSL_CTX_UseSupportedCurve</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_CTX_UseSupportedCurve(WOLFSSL_CTX* ctx, unsigned short name);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function is called on the client side to enable the use of Supported Elliptic Curves Extension for SSL objects created from the SSL context passed in the &#39;ctx&#39; parameter. It means that the supported curves enabled will be sent on ClientHello by wolfSSL clients. This function can be called more than one time to enable multiple curves.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;is the error that will be returned in one of these cases:</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; * ctx is NULL</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; * name is a unknown value. (see below)</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_E</span><span class="c2">&nbsp;is the error returned when there is not enough memory.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ctx</span><span class="c2">&nbsp;- pointer to a SSL context, created with wolfSSL_CTX_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">name</span><span class="c2">&nbsp;- indicates which curve will be supported for the session. The available options are:</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; enum {</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WOLFSSL_ECC_SECP160R1 = 0x10,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WOLFSSL_ECC_SECP192R1 = 0x13,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WOLFSSL_ECC_SECP224R1 = 0x15,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WOLFSSL_ECC_SECP256R1 = 0x17,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WOLFSSL_ECC_SECP384R1 = 0x18,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WOLFSSL_ECC_SECP521R1 = 0x19</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; };</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx = 0;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ctx == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // context creation failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_CTX_UseSupportedCurve(ctx, WOLFSSL_ECC_SECP256R1);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ret != 0) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // Elliptic Curve Extension usage failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4"><span class="c2">wolfSSL_UseSupportedCurve</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <h3 class="c7 c4"><a name="h.ndnkon67ui3u"></a><span>wolfSSL_UseSupportedCurve</span></h3>
    <p class="c4 c5"><span class="c2 c3"></span></p>
    <p class="c4"><span class="c6 c2">Synopsis:</span></p>
    <p class="c4"><span class="c2">#include &lt;wolfssl/ssl.h&gt;</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2">int wolfSSL_UseSupportedCurve(WOLFSSL* ssl, unsigned short name);</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Description:</span></p>
    <p class="c4"><span class="c2">This function is called on the client side to enable the use of Supported Elliptic Curves Extension in the SSL object passed in the &#39;ssl&#39; parameter. It means that the supported curves enabled will be sent on ClientHello by wolfSSL clients. This function can be called more than one time to enable multiple curves.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Return Values:</span></p>
    <p class="c4"><span class="c2">If successful the call will return </span><span class="c2 c3">SSL_SUCCESS</span><span class="c2">.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">BAD_FUNC_ARG</span><span class="c2">&nbsp;is the error that will be returned in one of these cases:</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; * ssl is NULL</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; * name is a unknown value. (see below)</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">MEMORY_E</span><span class="c2">&nbsp;is the error returned when there is not enough memory.</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Parameters:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c2 c3">ssl</span><span class="c2">&nbsp;- pointer to a SSL object, created with wolfSSL_new().</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c2 c3">name</span><span class="c2">&nbsp;- indicates which curve will be supported for the session. The available options are:</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; enum {</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WOLFSSL_ECC_SECP160R1 = 0x10,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WOLFSSL_ECC_SECP192R1 = 0x13,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WOLFSSL_ECC_SECP224R1 = 0x15,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WOLFSSL_ECC_SECP256R1 = 0x17,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WOLFSSL_ECC_SECP384R1 = 0x18,</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WOLFSSL_ECC_SECP521R1 = 0x19</span></p>
    <p class="c4"><span class="c2">&nbsp; &nbsp; };</span></p>
    <p class="c4 c5"><span class="c2"></span></p>
    <p class="c4"><span class="c6 c2">Example:</span></p>
    <p class="c4 c5"><span class="c6 c2"></span></p>
    <p class="c4"><span class="c0">int ret = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL_CTX* ctx = 0;</span></p>
    <p class="c4"><span class="c0">WOLFSSL* ssl = 0;</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ctx = wolfSSL_CTX_new(method);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ctx == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // context creation failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ssl = wolfSSL_new(ctx);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ssl == NULL) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // ssl creation failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">ret = wolfSSL_UseSupportedCurve(ssl, WOLFSSL_ECC_SECP256R1);</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c0">if (ret != 0) {</span></p>
    <p class="c4"><span class="c0">&nbsp; &nbsp; // Elliptic Curve Extension usage failed</span></p>
    <p class="c4"><span class="c0">}</span></p>
    <p class="c4 c5"><span class="c0"></span></p>
    <p class="c4"><span class="c6 c2">See Also:</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_new</span></p>
    <p class="c4"><span class="c2">wolfSSL_CTX_UseSupportedCurve</span></p>
    <p class="c4 c5 c21"><span></span></p>
</body>

</html>