# ライブラリデザイン

## ライブラリヘッダー

wolfSSL 2.0.0 RC3以降のリリースでは、ライブラリヘッダファイルを以下の場所に配置しています。

* wolfSSL: `wolfssl/`
* wolfCrypt: `wolfssl/wolfcrypt/`
* wolfSSL OpenSSL互換レイヤー: `wolfssl/openssl/`

OpenSSL互換レイヤーを使用する場合、`/wolfssl/openssl/ssl.h`ヘッダーをインクルードする必要があります。
[第13章 OpenSSL互換性](chapter13.md)も併せてご参照ください。

```c
#include <wolfssl/openssl/ssl.h>
```

wolfSSLネイティブAPIのみを使用する場合は、`/wolfssl/ssl.h`ヘッダーのみをインクルードする必要があります。

```c
#include <wolfssl/ssl.h>
```

## 起動と終了

すべてのアプリケーションは、ライブラリを使用する前に`wolfSSL_Init()`、プログラム終了時に`wolfSSL_Cleanup()`を呼び出す必要があります。
現在、これらの関数はマルチユーザーモードでセッションキャッシュ用の共有ミューテックスを初期化および解放するだけです。
しかし、将来的にはより多くの処理を実行する可能性があるため、常にこれらを実行することをお勧めします。

## 構造体の使用

wolfSSL 2.0.0 RC3リリースではヘッダーファイルの場所の変更に加え、wolfSSLのネイティブAPIとOpenSSL互換レイヤーをより明確に区別するようにしました。
これに伴い、wolfSSLのネイティブAPIで使用されるSSL/TLS構造体の名前を変更しています。
新しい構造体は以下の通りです。
なおOpenSSL互換レイヤーを使用する場合は、引き続き旧称を使用します。
詳細は [第13章 OpenSSL互換性](chapter13.md) をご参照ください。

* `WOLFSSL`         （旧称：SSL）
* `WOLFSSL_CTX`     （旧称：SSL_CTX）
* `WOLFSSL_METHOD`      （旧称：SSL_METHOD）
* `WOLFSSL_SESSION` （旧称：SSL_SESSION）
* `WOLFSSL_X509`        （旧称：X509）
* `WOLFSSL_X509_NAME`   （旧称：X509_NAME）
* `WOLFSSL_X509_CHAIN`  （旧称：X509_CHAIN）

## スレッドセーフ

wolfSSLはスレッドセーフとなるよう設計しています。
グローバルデータ、静的データ、オブジェクトの共有を避けているため、複数のスレッドが競合せず同時にライブラリに入ることができます。
ユーザーは、いくつかの領域で潜在的な問題を避けるよう注意する必要があります。

1. クライアントは複数のスレッド間で`WOLFSSL`オブジェクトを共有できますが、アクセスは同期する必要があります。つまり、同じSSLポインタを持つ2つの異なるスレッドから同時にRead/Writeすることはできません。

    wolfSSLは共有できない関数に入ったときにより積極的（制約的）な姿勢をとり、他のユーザーをロックアウトする可能性があります。
    すべてのユーザー（シングルスレッドのユーザーでさえ）はロックの負荷を負担し、マルチスレッドユーザーはスレッド間でオブジェクトを共有していなくても、ライブラリに再入力できません。
    このペナルティは高すぎるように思えますが、wolfSSLは共有オブジェクトを同期する責任をユーザーの手に委ねています。

2. `WOLFSSL`ポインタの共有に加えて、ユーザーは構造体を`wolfSSL_new()`に渡す前に`WOLFSSL_CTX`を完全に初期化する必要があります。同じ`WOLFSSL_CTX`で複数の`WOLFSSL`構造体を作成できますが、`WOLFSSL_CTX`は`wolfSSL_new()`作成時にのみ読み取られ、`WOLFSSL`オブジェクトが作成されると、`WOLFSSL_CTX`への将来の（または同時の）変更は反映されません。

    繰り返しになりますが、複数のスレッドは`WOLFSSL_CTX`への書き込みアクセスを同期させるべきであり、上記の同期と更新の問題を避けるために、単一のスレッドが`WOLFSSL_CTX`を初期化することをお勧めします。

3. 一部の最適化では、スレッドごとにメモリが割り当てられます。固定小数点ECCキャッシュが有効になっている場合（`FP_ECC`）、スレッドはスレッド終了前に`wc_ecc_fp_free()`を使用してキャッシュされたバッファをリリースする必要があります。

## 入力と出力バッファ

wolfSSLは、入力と出力に動的バッファを使用しています。
これらはデフォルトで0バイトであり、`wolfssl/internal.h`の`RECORD_SIZE`定義によって制御されます。
静的バッファよりも大きな入力レコードを受信した場合、一時的に動的バッファが使用され、その後解放されます。
静的バッファサイズは`MAX_RECORD_SIZE`（2^16または16,384）にて設定できます。

以前のwolfSSLの動作方法（動的メモリを必要としない16Kbの静的バッファ）を希望する場合は、`LARGE_STATIC_BUFFERS`を定義することで、その動作を引き続き使用できます。

動的バッファが使用され、ユーザーがバッファサイズより大きい`wolfSSL_write()`をリクエストした場合、`MAX_RECORD_SIZE`までの動的ブロックがデータを送信するために使用されます。
データを最大で`RECORD_SIZE`サイズのチャンクでのみ送信したいユーザーは、`STATIC_CHUNKS_ONLY`を定義してください。
これにより、wolfSSLは`RECORD_SIZE`（デフォルトでは128バイト）まで拡大するI/Oバッファを使用するようになります。
